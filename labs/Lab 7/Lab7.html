<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lab7 – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#system-overview" id="toc-system-overview" class="nav-link" data-scroll-target="#system-overview">System Overview</a>
  <ul class="collapse">
  <li><a href="#spi-interface-fpga-side" id="toc-spi-interface-fpga-side" class="nav-link" data-scroll-target="#spi-interface-fpga-side">SPI Interface (FPGA side)</a></li>
  </ul></li>
  <li><a href="#design-approach" id="toc-design-approach" class="nav-link" data-scroll-target="#design-approach">Design Approach</a>
  <ul class="collapse">
  <li><a href="#datapath" id="toc-datapath" class="nav-link" data-scroll-target="#datapath">Datapath</a></li>
  <li><a href="#controller-fsm" id="toc-controller-fsm" class="nav-link" data-scroll-target="#controller-fsm">Controller (FSM)</a></li>
  <li><a href="#key-expansion-aes-128" id="toc-key-expansion-aes-128" class="nav-link" data-scroll-target="#key-expansion-aes-128">Key Expansion (AES-128)</a></li>
  </ul></li>
  <li><a href="#implementation-notes" id="toc-implementation-notes" class="nav-link" data-scroll-target="#implementation-notes">Implementation Notes</a></li>
  <li><a href="#test-plan" id="toc-test-plan" class="nav-link" data-scroll-target="#test-plan">Test Plan</a>
  <ul class="collapse">
  <li><a href="#functional-vectors-core-tb" id="toc-functional-vectors-core-tb" class="nav-link" data-scroll-target="#functional-vectors-core-tb">Functional Vectors (Core TB)</a></li>
  <li><a href="#end-to-end-spi-spi-tb" id="toc-end-to-end-spi-spi-tb" class="nav-link" data-scroll-target="#end-to-end-spi-spi-tb">End-to-End SPI (SPI TB)</a></li>
  <li><a href="#logic-analyzer-hardware" id="toc-logic-analyzer-hardware" class="nav-link" data-scroll-target="#logic-analyzer-hardware">Logic Analyzer (Hardware)</a></li>
  </ul></li>
  <li><a href="#mcu-fpga-interface" id="toc-mcu-fpga-interface" class="nav-link" data-scroll-target="#mcu-fpga-interface">MCU ↔︎ FPGA Interface</a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#time-spent" id="toc-time-spent" class="nav-link" data-scroll-target="#time-spent">Time Spent</a></li>
  <li><a href="#known-limitations-future-work" id="toc-known-limitations-future-work" class="nav-link" data-scroll-target="#known-limitations-future-work">Known Limitations / Future Work</a></li>
  <li><a href="#ai-prototype" id="toc-ai-prototype" class="nav-link" data-scroll-target="#ai-prototype">AI Prototype</a>
  <ul class="collapse">
  <li><a href="#prototype-a-with-spec-fips-197-available" id="toc-prototype-a-with-spec-fips-197-available" class="nav-link" data-scroll-target="#prototype-a-with-spec-fips-197-available">Prototype A — With Spec (FIPS-197 available)</a></li>
  <li><a href="#prototype-b-without-spec-no-aes-mention" id="toc-prototype-b-without-spec-no-aes-mention" class="nav-link" data-scroll-target="#prototype-b-without-spec-no-aes-mention">Prototype B — Without Spec (No “AES” Mention)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<hr>
<p>title: “Lab 7: AES-128 Hardware Accelerator &amp; SPI MCU Link” description: “Iterative AES core on FPGA with SPI front-end; MCU sends key/plaintext and verifies ciphertext; debug with a logic analyzer” author: “Santiago Burgos-Fallon” date: “10/30/25” categories: -Labs draft: false</p>
<hr>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In this lab I implemented a <strong>128-bit AES encryption accelerator</strong> in SystemVerilog and wrapped it with a simple <strong>SPI shift interface</strong> so an MCU can send a key and plaintext and read back the ciphertext. The AES core is an <strong>iterative, multi-cycle</strong> design (1 round per few cycles) sized to the FPGA’s resources. I verified function first in simulation (core TB, then SPI TB), then used a <strong>logic analyzer</strong> to confirm timing and bit ordering on the hardware link.</p>
<p><strong>Learning outcomes:</strong> specification-driven design, datapath + controller partitioning, MCU↔︎FPGA interface timing, structured debug with simulation + LA, and a taste of hardware acceleration.</p>
</section>
<section id="system-overview" class="level2">
<h2 class="anchored" data-anchor-id="system-overview">System Overview</h2>
<p><strong>Top-level flow.</strong> MCU →(SPI: 256 SCK in)→ FPGA (<strong>aes_spi</strong>) → <strong>aes_core</strong> → ciphertext latched →(SPI: 128 SCK out)→ MCU, which compares against a known test vector.</p>
<p><strong>AES mode.</strong> AES-128, <strong>Nr = 10</strong> rounds (Nk = 4, Nb = 4). The round sequence is:</p>
<ul>
<li>Initial <strong>AddRoundKey</strong></li>
<li>Rounds 1–9: <strong>SubBytes → ShiftRows → MixColumns → AddRoundKey</strong></li>
<li>Round 10: <strong>SubBytes → ShiftRows → AddRoundKey</strong> (no MixColumns)</li>
</ul>
<div id="fig-block" class="quarto-float quarto-figure quarto-figure-center anchored" alt="block diagram schematic for design" data-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/blk.jpeg" class="img-fluid figure-img" style="width:90.0%" data-align="center" alt="block diagram schematic for design">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: block diagram Schematic.
</figcaption>
</figure>
</div>
<section id="spi-interface-fpga-side" class="level3">
<h3 class="anchored" data-anchor-id="spi-interface-fpga-side">SPI Interface (FPGA side)</h3>
<ul>
<li>Mode <strong>CPOL=0/CPHA=0</strong>: sample <code>sdi</code> on <strong>posedge SCK</strong>; update <code>sdo</code> on <strong>negedge SCK</strong>.</li>
<li><strong>Shift-in phase (256 edges):</strong> <code>{plaintext, key}</code> MSB-first.</li>
<li><strong>Compute phase:</strong> <code>load</code> deasserted; core runs ~11 fabric clocks and raises <code>done</code>.</li>
<li><strong>Shift-out phase (128 edges):</strong> cipher MSB-first; the <strong>first MSB</strong> is driven as soon as <code>done</code> rises (before next SCK edge), then <code>sdo</code> updates on negedges.</li>
</ul>
<p><strong>Insert logic-analyzer timing diagram here.</strong></p>
</section>
</section>
<section id="design-approach" class="level2">
<h2 class="anchored" data-anchor-id="design-approach">Design Approach</h2>
<section id="datapath" class="level3">
<h3 class="anchored" data-anchor-id="datapath">Datapath</h3>
<ul>
<li><strong>State register (128b)</strong> holds the current AES state.</li>
<li><strong>RoundKey register (128b)</strong> holds the active round key.</li>
<li><strong>SubBytes</strong>: 16× <code>sbox_sync</code> (1-cycle, uses BRAM; <code>sbox.txt</code> ROM init).</li>
<li><strong>ShiftRows</strong>: hard-wired byte permutes.</li>
<li><strong>MixColumns</strong>: 4× column units with GF(2^8) multiply-by-x helper (<code>galoismult</code> with poly <code>0x1B</code>).</li>
<li><strong>AddRoundKey</strong>: 4× 32-bit XORs.</li>
</ul>
</section>
<section id="controller-fsm" class="level3">
<h3 class="anchored" data-anchor-id="controller-fsm">Controller (FSM)</h3>
<p>States (conceptually):</p>
<ol type="1">
<li><strong>IDLE</strong> — wait for <code>load</code>; stage plaintext/key for initial ARK.</li>
<li><strong>INIT_ARK</strong> — compute <code>state = plaintext ^ key</code>.</li>
<li><strong>ROUND_PREP</strong> — present <code>state</code> to SubBytes; keyexp sees <code>{round, rk}</code>.</li>
<li><strong>SUB_ISSUE / SUB_CAPTURE</strong> — burn 1 cycle for <code>sbox_sync</code>, latch <code>SubBytes</code>.</li>
<li><strong>SR_STAGE</strong> — apply ShiftRows.</li>
<li><strong>MC_STAGE</strong> — apply MixColumns (skip when <code>round==10</code>).</li>
<li><strong>ARK_STAGE / ARK_FINAL</strong> — XOR with next round key; increment round; on final, latch <code>cyphertext</code> and assert <code>done</code>.</li>
<li><strong>FINISH</strong> — hold <code>done</code> high until next <code>load</code>.</li>
</ol>
<p><strong>Insert FSM state diagram here.</strong></p>
</section>
<section id="key-expansion-aes-128" class="level3">
<h3 class="anchored" data-anchor-id="key-expansion-aes-128">Key Expansion (AES-128)</h3>
<ul>
<li>Implements <strong>RotWord → SubWord → XOR with Rcon</strong> on the last word, then chained XORs to form the next 128-bit round key.</li>
<li><strong>Rcon</strong> sequence uses <code>{0x01, 0x02, 0x04, …, 0x1B, 0x36}</code> for rounds 1..10.</li>
<li>SubWord uses the same <strong>sbox_sync</strong> (1-cycle).</li>
</ul>
<p><strong>Insert KeyExpansion schematic snippet here.</strong></p>
</section>
</section>
<section id="implementation-notes" class="level2">
<h2 class="anchored" data-anchor-id="implementation-notes">Implementation Notes</h2>
<ul>
<li>The <strong>iterative core</strong> fits comfortably; the S-box is the dominant area (maps to BRAM/LUT RAM depending on tool inference).</li>
<li>Because <strong>sbox_sync</strong> is synchronous, I inserted an explicit <strong>one-cycle gap</strong> between presenting bytes and capturing the substituted result.</li>
<li>The <strong>final round</strong> bypasses MixColumns via a small mux on the ARK input.</li>
<li>The <strong>SPI</strong> module double-buffers the outbound ciphertext so <code>sdo</code> is valid <strong>immediately</strong> on <code>done</code> and then continues shifting on SCK negedges.</li>
</ul>
</section>
<section id="test-plan" class="level2">
<h2 class="anchored" data-anchor-id="test-plan">Test Plan</h2>
<section id="functional-vectors-core-tb" class="level3">
<h3 class="anchored" data-anchor-id="functional-vectors-core-tb">Functional Vectors (Core TB)</h3>
<ul>
<li><p><strong>NIST AES-128 example</strong> (Appendix A/B):</p>
<ul>
<li><code>key = 2b7e151628aed2a6abf7158809cf4f3c</code></li>
<li><code>plaintext = 3243f6a8885a308d313198a2e0370734</code></li>
<li><strong>Expected</strong> <code>ciphertext = 3925841d02dc09fbdc118597196a0b32</code></li>
</ul></li>
<li><p>The core TB drives <code>load</code>, clocks through 10 rounds, and checks <code>done</code> and the final value.</p></li>
</ul>
<div id="fig-block" class="quarto-float quarto-figure quarto-figure-center anchored" alt="block diagram schematic for design" data-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/core waves.png" class="img-fluid figure-img" style="width:90.0%" data-align="center" alt="block diagram schematic for design">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: core wave forms.
</figcaption>
</figure>
</div>
</section>
<section id="end-to-end-spi-spi-tb" class="level3">
<h3 class="anchored" data-anchor-id="end-to-end-spi-spi-tb">End-to-End SPI (SPI TB)</h3>
<ul>
<li>Shifts <code>{plaintext, key}</code> MSB-first on <code>sdi</code> with <strong>256 posedges</strong>.</li>
<li>Deasserts <code>load</code> and waits for <code>done</code>.</li>
<li>Samples <code>sdo</code> on <strong>posedge SCK</strong> while I update it on <strong>negedge</strong> (128 cycles).</li>
<li>Compares the assembled 128-bit value with the golden.</li>
<li>On success, the TB prints “<strong>Testbench ran successfully</strong>” and calls <code>$stop</code> to allow wave inspection.</li>
</ul>
<div class="columns">
<div class="column" style="width:60%;">
<div id="fig-7seg-waves" class="quarto-float quarto-figure quarto-figure-center anchored" alt="spi waveform.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-7seg-waves-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/spi waves.png" class="img-fluid figure-img" alt="spi waveform.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-7seg-waves-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Spi waves.
</figcaption>
</figure>
</div>
</div><div class="column" style="width:40%;">
<div id="fig-7seg-log" class="quarto-float quarto-figure quarto-figure-center anchored" alt="all pass.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-7seg-log-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/spi output.png" class="img-fluid figure-img" alt="all pass.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-7seg-log-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Spi transcript.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="logic-analyzer-hardware" class="level3">
<h3 class="anchored" data-anchor-id="logic-analyzer-hardware">Logic Analyzer (Hardware)</h3>
<ul>
<li><p>Probes: <code>SCK</code>, <code>SDI</code>, <code>SDO</code>, <code>CE/NSS</code>, optionally <code>done</code> on a GPIO, and a few FSM state bits via spare pins.</p></li>
<li><p><strong>What to verify:</strong></p>
<ul>
<li>256 SCK edges during shift-in, 128 during shift-out.</li>
<li><code>SDO</code> <strong>changes on negedge</strong>, sampled on posedge.</li>
<li>First MSB presented right when <code>done</code> rises.</li>
<li>Bit order is <strong>MSB-first</strong> for both directions.</li>
</ul></li>
</ul>
<p><strong>Insert on-board capture here.</strong></p>
</section>
</section>
<section id="mcu-fpga-interface" class="level2">
<h2 class="anchored" data-anchor-id="mcu-fpga-interface">MCU ↔︎ FPGA Interface</h2>
<ul>
<li><p>The provided <code>lab7.c</code> drives the SPI transaction and compares the ciphertext locally. No changes needed as long as:</p>
<ul>
<li>CPOL/CPHA = <strong>0/0</strong> (match FPGA).</li>
<li><strong>NSS/CE</strong> held active during each continuous shift window.</li>
<li>Bit order <strong>MSB-first</strong>.</li>
</ul></li>
<li><p>On success, the MCU prints a pass banner and can toggle a status LED.</p></li>
</ul>
<p><strong>Insert MCU console screenshot here.</strong></p>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<ul>
<li><strong>Core TB:</strong> passes the NIST vector.</li>
<li><strong>SPI TB:</strong> passes end-to-end; ciphertext matches.</li>
<li><strong>Hardware LA:</strong> edge phasing, counts, and MSB-first ordering match expectations.</li>
<li>The iterative design meets timing at the board’s default fabric clock (internal LF/HS oscillator or system clock; I used the on-board oscillator block).</li>
</ul>
</section>
<section id="time-spent" class="level2">
<h2 class="anchored" data-anchor-id="time-spent">Time Spent</h2>
<p>~<strong>20 hours</strong> .</p>
</section>
<section id="known-limitations-future-work" class="level2">
<h2 class="anchored" data-anchor-id="known-limitations-future-work">Known Limitations / Future Work</h2>
<ul>
<li>Current core is <strong>encrypt-only</strong>; no decryption path.</li>
<li>One round per several cycles; could <strong>pipeline</strong> rounds for higher throughput (at area cost).</li>
<li>Add <strong>AXI-lite</strong> or memory-mapped interface for queued requests.</li>
<li>Parameterize for <strong>AES-192/256</strong> key sizes.</li>
</ul>
<p><strong>Schematic standards</strong>: labeled pins/parts/values, junction dots, left-to-right flow, neat layout, title block. <strong>HDL standards</strong>: one module/file, descriptive names, comments, clear hierarchy, individual module TBs, include TB outputs in report.</p>
<div id="fig-block" class="quarto-float quarto-figure quarto-figure-center anchored" alt="general diagram schematic for design" data-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/scm.jpeg" class="img-fluid figure-img" style="width:90.0%" data-align="center" alt="general diagram schematic for design">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: general schematic
</figcaption>
</figure>
</div>
</section>
<section id="ai-prototype" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype">AI Prototype</h2>
<section id="prototype-a-with-spec-fips-197-available" class="level3">
<h3 class="anchored" data-anchor-id="prototype-a-with-spec-fips-197-available">Prototype A — With Spec (FIPS-197 available)</h3>
<p><strong>Prompt.</strong> <em>“Write SystemVerilog HDL to implement the KeyExpansion logic described in the FIPS-197 uploaded document. The module should be purely combinational, using the previous key and current round number to calculate the next key. Assume other required modules (SubWord and RotWord) are already implemented.”</em></p>
<p><strong>Outcome (what happened).</strong> The LLM produced a clean combinational <code>keyexpansion</code> with:</p>
<ul>
<li>Correct <strong>Rcon</strong> mapping for rounds 1..10.</li>
<li><code>RotWord</code> then <code>SubWord</code> on <code>w3</code>, XOR chain <code>w0'..w3'</code>.</li>
<li>Proper port widths and MSB-first word ordering.</li>
</ul>
<p><strong>Analysis.</strong> It synthesized immediately. Because my in-lab design uses <strong>synchronous</strong> <code>SubWord</code> (via <code>sbox_sync</code>), I swapped the prototype’s pure-comb <code>SubWord</code> call for my existing registered version and inserted one holding cycle in the controller. The generated structure matched FIPS-197, so functional results were identical.</p>
</section>
<section id="prototype-b-without-spec-no-aes-mention" class="level3">
<h3 class="anchored" data-anchor-id="prototype-b-without-spec-no-aes-mention">Prototype B — Without Spec (No “AES” Mention)</h3>
<p><strong>Prompt.</strong> <em>(Rephrased, no “AES” terms; uses the provided abstract pseudocode with <code>module1</code>, <code>module2</code>, <code>Rcon</code> and loop unrolling instructions.)</em></p>
<p><strong>Outcome (what happened).</strong> The LLM generated a module that:</p>
<ul>
<li>Preserved the <strong>word-wise recurrence</strong> and XOR chain.</li>
<li>Exposed a param for <strong>Nk</strong> and <strong>Nr</strong>, but mis-handled <code>Rcon</code> for <code>i/Nk ≥ 9</code> (missed <code>0x1B</code>→<code>0x36</code> step).</li>
<li>Treated <code>module1</code>/<code>module2</code> as black-box instances correctly, but defaulted them to combinational timing.</li>
</ul>
<p><strong>Analysis.</strong> Functionally close but <strong>not spec-exact</strong> (Rcon corner), which is expected without domain context. After I fixed the Rcon table and aligned timing to my synchronous <code>SubWord</code>, it matched Prototype A. <strong>Takeaway:</strong> LLMs can mirror <strong>control/data recurrences</strong> from pseudocode well, but spec-driven constants (like Rcon sequences) still need expert review.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/s4anti4go\.github\.io\/E155\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>