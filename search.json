[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "First Post!\n\n\nWhat Im looking forward to in Micro P’s\n\n\n\n\n\nAug 29, 2024\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "Labs",
    "section": "",
    "text": "Lab 7: The Advanced Encryption Standard\n\n\nA hardware accelerator to perform 128-bit AES encryption\n\n\n\n\n\nOct 9, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6: The Internet of Things and Serial Peripheral Interface\n\n\nAn internet-accessible device to control an onboard LED and measure ambient temperature\n\n\n\n\n\nOct 2, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4: Digital Audio — Für Elise on STM32L432KC\n\n\nSquare-wave audio synthesis with timer-driven GPIO → LM386 → 8 Ω speaker. No CMSIS; bare-metal register macros.\n\n\n\n\n\nSep 30, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5: Interrupts\n\n\nUse MCU to determine the speed of a motor by reading from a quadrature encoder using interrupts.\n\n\n\n\n\nSep 25, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3: Keypad Scanner\n\n\n4×4 matrix keypad scanner with debouncing, single-event registration, and dual 7-segment output\n\n\n\n\n\nSep 17, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\nA time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins\n\n\n\n\n\nSep 11, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1: FPGA and MCU Setup and Testing\n\n\nExplore the microcontroller unit (MCU) and field-programmable gate array (FPGA) development boards used in this course.\n\n\n\n\n\nAug 29, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/Lab 4/Lab4.html",
    "href": "labs/Lab 4/Lab4.html",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "",
    "text": "In this lab I used an STM32L432KC MCU to play music by toggling a GPIO at precise, timer-controlled rates and feeding the signal into an LM386 amplifier that drives an 8 Ω speaker. The score (Für Elise) is provided as a list of {frequency_Hz, duration_ms} pairs. A frequency of 0 is a rest, and a duration of 0 ends the song.\nI implemented everything without CMSIS: only #define memory-mapped register macros and small helper functions.\n\n\n\nBuild a circuit to let an MCU I/O pin drive a speaker (via LM386).\nImplement timer functionality by reading the datasheet and writing a tiny device driver from scratch.\nGenerate accurate pitches independent of note frequency and respect the specified durations."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#introduction",
    "href": "labs/Lab 4/Lab4.html#introduction",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "",
    "text": "In this lab I used an STM32L432KC MCU to play music by toggling a GPIO at precise, timer-controlled rates and feeding the signal into an LM386 amplifier that drives an 8 Ω speaker. The score (Für Elise) is provided as a list of {frequency_Hz, duration_ms} pairs. A frequency of 0 is a rest, and a duration of 0 ends the song.\nI implemented everything without CMSIS: only #define memory-mapped register macros and small helper functions.\n\n\n\nBuild a circuit to let an MCU I/O pin drive a speaker (via LM386).\nImplement timer functionality by reading the datasheet and writing a tiny device driver from scratch.\nGenerate accurate pitches independent of note frequency and respect the specified durations."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#system-overview",
    "href": "labs/Lab 4/Lab4.html#system-overview",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "System Overview",
    "text": "System Overview\n\nTimer plan: prescale TIM2 to a 1 MHz tick (1 µs per timer count). For a note of frequency ( f ), set the timer auto-reload to the half-period in µs and toggle the GPIO on every update event → 50% duty square wave by construction.\nDuration plan: compute how many half-periods fit in the requested milliseconds and toggle exactly that many times.\nRests: keep the output low and wait for ms timer updates at 1 kHz (ARR = 999 at a 1 MHz tick).\n\nPins used (hardware build): Audio out PA11 (GPIO to LM386 IN+ via pot/divider), START = PB4 (active-low to GND, internal pull-up), RESET = PA6 (active-low to GND, internal pull-up)."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#hardware",
    "href": "labs/Lab 4/Lab4.html#hardware",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Hardware",
    "text": "Hardware\n\nLM386 minimum-parts hookup\n\nInput network:\n\n10 kΩ potentiometer (recommended): MCU pin → pot top; pot bottom → GND; wiper → LM386 pin 3 (IN+) (volume).\n\nLM386 pins:\n\nPin 3 (IN+): from pot wiper or divider node.\n\nPin 2 (IN−) and Pin 4: GND.\n\nPin 5 (OUT): → 220–250 µF electrolytic (+ toward LM386) → speaker +; speaker − → GND; add 0.047–0.05 µF from pin 5 → GND (stability).\n\nPin 6 (V_S): +5…9 V with 0.1 µF (and 10 µF) decoupling to GND near the IC.\n\nPins 1 & 8: open (gain ≈ 20).\n\n\n\nCommon ground: MCU GND, LM386 GND, and speaker − must be tied together."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#timing-accuracy-detailed-calculations-1-µs-timer-tick-tim2-32-bit",
    "href": "labs/Lab 4/Lab4.html#timing-accuracy-detailed-calculations-1-µs-timer-tick-tim2-32-bit",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Timing & Accuracy — Detailed Calculations (1 µs Timer Tick, TIM2 32-bit)",
    "text": "Timing & Accuracy — Detailed Calculations (1 µs Timer Tick, TIM2 32-bit)\nAssumptions:\nTIM2 prescaled to 1 MHz (1 µs per count), upcount to ARR, toggle GPIO on each update (so each update = one half-period). Frequencies are produced by rounding the half-period; durations are produced by counting half-periods. TIM2 on STM32L432 is 32-bit.\n\nCore Formulae\nHalf-period in microseconds for target frequency ( f ) (Hz): \\[\nT_{1/2} \\;=\\; \\frac{1}{2f}\\ \\text{s} \\;=\\; \\frac{500{,}000}{f}\\ \\text{µs}\n\\]\nProgram auto-reload as: \\[\nARR \\;=\\; \\operatorname{round}(T_{1/2}) \\;-\\; 1\n\\]\nActual frequency (because timer quantizes in 1 µs steps): \\[\nf_{\\text{actual}} \\;=\\; \\frac{1}{2\\,\\bigl(ARR+1\\bigr)\\cdot1\\ \\text{µs}}\n\\;=\\;\n\\frac{500{,}000}{ARR+1}\\ \\text{Hz}\n\\]\nPer-half-period rounding is at most ±0.5 µs. Over the full period (two half-periods), the relative pitch error is bounded by: \\[\n\\left|\\frac{\\Delta f}{f}\\right| \\;\\lesssim\\; \\frac{f}{10^{6}}\n\\quad\\text{(with 1 µs tick)}\n\\]\nAt 1 kHz → ≤ 0.10 %; at 220 Hz → ≤ 0.022 % (≪ 1 %).\n\n\n\nTheoretical Frequency Limits (Timer-Only)\nUsing 1 µs tick and a 32-bit auto-reload:\n\nMinimum frequency largest half-period, \\((ARR_{max}= 2^{32}-1)\\): \\[\nT_{1/2,\\max}=(ARR_{\\max}+1)\\cdot1\\,\\text{µs}=4{,}294{,}967{,}296\\ \\text{µs}\n=4{,}294.967296\\ \\text{s}\n\\] Full period 8,589.934592 s. \\[\n\\boxed{f_{\\min}=\\frac{1}{8{,}589.934592}\\ \\text{Hz}=\\mathbf{0.0001164153\\ Hz}}\n\\] (period ≈ 2 h 23 m 10 s)\nMaximum frequency (smallest half-period, (ARR=0)): \\[\nT_{1/2,\\min}=1\\,\\text{µs}\\;\\Rightarrow\\;T=2\\,\\text{µs},\\qquad\n\\boxed{f_{\\max}=\\mathbf{500{,}000\\ Hz}}\n\\]\n\n\n\n\nRepresentative Notes — Actual Values (from round-to-µs)\n\n\n\n\n\n\n\n\n\n\nTarget (f) (Hz)\n(T_{1/2}) ideal (µs) → rounded\n(ARR)\n(f_{}) (Hz)\nError\n\n\n\n\n220.0\n2272.727… → 2273\n2272\n219.9736\n−0.012 %\n\n\n329.6\n1516.989… → 1517\n1516\n329.5979\n−0.00064 %\n\n\n440.0\n1136.364… → 1136\n1135\n440.1408\n+0.032 %\n\n\n523.3\n955.467… → 955\n954\n523.5602\n+0.050 %\n\n\n659.3\n758.380… → 758\n757\n659.6306\n+0.050 %\n\n\n1000.0\n500.000… → 500\n499\n1000.0000\n+0.000 %\n\n\n\n\nFrequency step size near a given (f) from a 1 µs half-period grid is approximately\n(f ). Examples: at 1 kHz → ~2 Hz/step; at 220 Hz → ~0.097 Hz/step.\n\n\n\nDuration Quantization (Notes): What it is, why it happens, and how big the error is\nModel. Each note is played by executing an integer number of half-periods (one GPIO toggle per timer update).\nLet the target frequency be (f) (Hz) and the requested duration be (d) (ms).\n\nHalf-period (with a 1 µs timer tick): \\[\nT_{1/2} \\;=\\; \\frac{1}{2f}\\ \\text{s} \\;=\\; \\frac{500{,}000}{f}\\ \\mu\\text{s}\n\\]\nIdeal (real-valued) number of toggles: \\[\nN^* \\;=\\; \\frac{2 f d}{1000}\n\\]\nImplemented toggles (what code uses): (N=(N^*)) (nearest integer).\nActual time played: \\[\nt_{\\text{actual}} \\;=\\; N\\cdot T_{1/2}\n\\]\n\nWhy quantization error occurs. Because (N) must be an integer, (N) can differ from \\((N^*)\\) by at most \\((T_{1/2})\\). Multiplying by \\((T_{1/2})\\) gives the worst-case time error: \\[\n\\boxed{\\,|\\Delta t_{\\text{note}}| \\;\\le\\; \\tfrac{1}{2}\\,T_{1/2}\\,}\n\\]\nInterpretation. - The step size of note duration is exactly \\[(T_{1/2})\\] (each additional toggle adds one half-period). - The largest absolute error happens at low frequencies \\[(large (T_{1/2}))\\], because the duration “grid” is coarser. - For a given requested duration (d) (e.g., 125 ms), the percent error bound is \\[\n  \\boxed{\\,\\%\\text{error} \\;\\le\\; \\frac{T_{1/2}}{2\\,d}\\times 100\\%\\,}\n  \\]\n\n\nExplicit values\n\n( f = 220, ):\n\\[\nT_{1/2} = \\frac{500{,}000}{220} = 2272.727\\,\\mu\\text{s} = \\mathbf{2.273\\,\\text{ms}}\n\\] \\[\n|\\Delta t| \\le \\tfrac{1}{2}T_{1/2} = \\mathbf{1.136\\,\\text{ms}}\n\\] \\[\n\\%\\text{error} \\le \\frac{2.273}{2\\cdot 125}\\times 100\\% = \\mathbf{0.91\\%}\n\\]\n( f = 440, ):\n\\[\nT_{1/2} = \\frac{500{,}000}{440} = 1136.364\\,\\mu\\text{s} = \\mathbf{1.136\\,\\text{ms}}\n\\] \\[\n|\\Delta t| \\le \\mathbf{0.568\\,\\text{ms}}\n\\] \\[\n\\%\\text{error} \\le \\frac{1.136}{2\\cdot 125}\\times 100\\% = \\mathbf{0.45\\%}\n\\]\n( f = 659.3, ):\n\\[\nT_{1/2} = \\frac{500{,}000}{659.3} = 758.380\\,\\mu\\text{s} = \\mathbf{0.758\\,\\text{ms}}\n\\] \\[\n|\\Delta t| \\le \\mathbf{0.379\\,\\text{ms}}\n\\] \\[\n\\%\\text{error} \\le \\frac{0.758}{2\\cdot 125}\\times 100\\% = \\mathbf{0.30\\%}\n\\]\n( f = 1000, ):\n\\[\nT_{1/2} = \\frac{500{,}000}{1000} = 500.000\\,\\mu\\text{s} = \\mathbf{0.500\\,\\text{ms}}\n\\] \\[\n|\\Delta t| \\le \\mathbf{0.250\\,\\text{ms}}\n\\] \\[\n\\%\\text{error} \\le \\frac{0.500}{2\\cdot 125}\\times 100\\% = \\mathbf{0.20\\%}\n\\]\n\n\nRests: handled by a 1 kHz “ms timer” → granularity 1 ms. Since your rest durations are already integers in ms, the rest error is 0 ms (within that 1 ms quantum).\n\n\n\n\n\nSoftware-Polled Limitations (Practical Upper Bound)\nI implement notes by polling TIM2’s update flag (UIF), then clearing UIF and toggling the GPIO. The timer can generate very fast updates, but to avoid missed toggles the CPU must service each update before the next half-period elapses.\nLet\n\n\\(f_{cpu}\\) = core clock (e.g., 80 MHz)\n\n\\(t_{service}\\) = time for me to (1) detect UIF=1 and exit the loop, (2) clear TIM2_SR, and (3) toggle the ODR bit (plus loop overhead)\n\nTo guarantee no misses I need the half-period to exceed my service time:\n\\[\nT_{1/2} \\;&gt;\\; t_{\\text{service}}\n\\quad\\Longrightarrow\\quad\nf_{\\max,\\text{service}} \\;\\approx\\; \\frac{1}{2\\,t_{\\text{service}}}\n\\]\n\nConcrete examples\n\\[t_{\\text{service}} = 2.0,\\mu\\text{s}\\] \\[\n  f_{\\max,\\text{service}} \\approx \\frac{1}{2\\cdot 2.0\\,\\mu\\text{s}} = \\mathbf{250\\,\\text{kHz}}\n  \\] \\[t_{\\text{service}} = 1.0,\\mu\\text{s}\\] \\[\n  f_{\\max,\\text{service}} \\approx \\frac{1}{2\\cdot 1.0\\,\\mu\\text{s}} = \\mathbf{500\\,\\text{kHz}}\n  \\] \\[t_{\\text{service}} = 0.5,\\mu\\text{s}\\] \\[\n  f_{\\max,\\text{service}} \\approx \\frac{1}{2\\cdot 0.5\\,\\mu\\text{s}} = \\mathbf{1.0\\,\\text{MHz}}\n  \\]\nHowever, with my 1 µs timer tick, the timer itself caps the maximum frequency at\n\\[\nf_{\\max,\\text{timer}} \\;=\\; \\frac{1}{2\\cdot 1\\,\\mu\\text{s}} \\;=\\; \\mathbf{500\\,\\text{kHz}}\n\\]\nSo the true practical max is\n\\[\nf_{\\max} \\;=\\; \\min\\!\\bigl(f_{\\max,\\text{service}},\\, f_{\\max,\\text{timer}}\\bigr)\n\\]\nIn other words:\n\nIf \\(t_{service}\\) &gt; 1s → software-limited below 500 kHz\n\nIf \\(t_{service}\\) &lt; 1s → timer-limited at 500 kHz\n\nEither way, this is orders of magnitude above audio. My Für Elise range (220–1319 Hz) is tiny compared to even a conservative software-limited few-hundred-kHz ceiling.\n\n\n\n\nCompliance Statement (from these calculations)\n\nPitch accuracy (220–1000 Hz): worst-case rounding ≤ 0.10 % @1 kHz and ≤ 0.022 % @220 Hz → meets ±1 % spec with wide margin.\nDurations: note-length error ≤ ½ (T_{1/2}) (≤ 0.25–1.14 ms across 1 kHz–220 Hz for 125 ms notes); rests at 1 ms resolution → tempo is within ~1 % worst case, typically ≪ 1 %.\nRange: timer math supports (f) from 0.000116 Hz up to 500 kHz; software-service considerations are still far above the audio range used here."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#schematic",
    "href": "labs/Lab 4/Lab4.html#schematic",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 1: General Schematic."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#writeup-summary-general-specs",
    "href": "labs/Lab 4/Lab4.html#writeup-summary-general-specs",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Writeup / Summary (General Specs)",
    "text": "Writeup / Summary (General Specs)\n\nMeets requirements? Yes.\n\nTime spent: 6 hours.\n\nAI prototype: attempted; reflection below."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#verification-bring-up",
    "href": "labs/Lab 4/Lab4.html#verification-bring-up",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Verification & Bring-Up",
    "text": "Verification & Bring-Up\n\nFunctional checks\n\nRests (f = 0) produce silence for specified ms.\n\nEnd marker (duration = 0) terminates playback cleanly.\n\nSTART (PB4) gates initial playback; RESET (PA6) aborts mid-note.\n\nDebugging approach\n\nAdded debug watches for computed ( ARR ), half-period, and toggle counts.\n\nUsed run + hit-count breakpoints (not single-step), since stepping halts the timer and audio.\n\nLED telemetry for “in-note vs rest” helps confirm tempo without a scope."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#ai-prototype-reflection",
    "href": "labs/Lab 4/Lab4.html#ai-prototype-reflection",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "AI Prototype & Reflection",
    "text": "AI Prototype & Reflection\n\nPrompt used\n\nNoteLLM Prompt\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220 Hz to 1 kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\n\n\nReflection\n\nQuality & speed: The LLM quickly identified a general-purpose timer (TIM2/TIM3), the key equations \\[\nf = \\frac{f_{\\text{TIM}}}{(PSC+1)(ARR+1)},\\qquad ARR \\approx \\frac{f_{\\text{TIM}}}{f(PSC+1)}-1\n\\] and discussed PWM vs. toggle-on-update. It was faster than manual document search when I couldn’t recall register names.\nWith datasheet attached: Accuracy improved—calling out that TIM2 is 32-bit on L4 and lives on APB1 helped bound ranges and justify a 1 MHz tick.\nCompared to my approach: I chose toggle-on-update to guarantee 50% duty without CCR/PWM setup (simpler for an LM386 square-wave input).\n\nLLM as doc search: Helpful for where to look and order of operations (RCC → GPIO → TIM), while I still verified addresses/bitfields in the reference manual.\nTips that worked: Specify the target tick (e.g., “make TIM2 1 MHz”), request the exact init sequence, and state pin constraints so it doesn’t assume PWM unless I want it."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#conclusions",
    "href": "labs/Lab 4/Lab4.html#conclusions",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Conclusions",
    "text": "Conclusions\nThe design satisfies the lab requirements:\n\nPlays Für Elise at the specified tempo with accurate pitches and rests.\nUses bare-metal register macros; no CMSIS.\nTiming math demonstrates ≤ 0.1% typical pitch error (≪ 1%) in 220–1000 Hz.\nThe LM386 stage is correctly biased and decoupled; the MCU never drives the speaker directly.\n\nTime spent: 6 hours.\nFuture work: add a second composition; experiment with PWM+CCR for variable duty or an RC-filtered DAC for softer timbre."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html",
    "href": "labs/Lab 2/Lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab I implemented time-multiplexing to drive a dual common‑anode seven‑segment display using a single hex→segments decoder module. Two 4‑bit nibbles (from DIP switches) are alternately presented to the decoder; high‑side PNP transistors enable exactly one digit at a time. I also displayed the 5‑bit sum of the two hexadecimal inputs on five LEDs and verified safe currents per the iCE40‑UP5K datasheet (§4.17). Designs were simulated in QuestaSim and synthesized in Lattice Radiant."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#introduction",
    "href": "labs/Lab 2/Lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab I implemented time-multiplexing to drive a dual common‑anode seven‑segment display using a single hex→segments decoder module. Two 4‑bit nibbles (from DIP switches) are alternately presented to the decoder; high‑side PNP transistors enable exactly one digit at a time. I also displayed the 5‑bit sum of the two hexadecimal inputs on five LEDs and verified safe currents per the iCE40‑UP5K datasheet (§4.17). Designs were simulated in QuestaSim and synthesized in Lattice Radiant."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#design-testing-methodology",
    "href": "labs/Lab 2/Lab2.html#design-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design & Testing Methodology",
    "text": "Design & Testing Methodology\n\nArchitecture\n\n\n\n\n\n\nFigure 1: Block diagram of the top-level (top).\n\n\n\n\nClocking. The internal HF oscillator (HSOSC) runs at 6 MHz (CLKHF_DIV=2'b11).\n\nMultiplexer/Scan. Dmux divides the 6 MHz clock to a scan clock DivClk, selects which nibble feeds the decoder, and asserts the corresponding digit enable (En1, En2).\n\nDecoder. SevenSeg is a combinational hex→segments decoder with active‑LOW outputs for a common‑anode display (Seg[6:0], where Seg[0]=A … Seg[6]=G).\n\nTop‑level. top wires the pieces together and computes the 5‑bit sum on Sum[4:0] (LEDs are active‑LOW on our board, so the sum is inverted).\n\n\n\nMultiplex timing\nWith HSOSC at 6 MHz and terminal count N, Dmux toggles DivClk every N cycles; the scan frequency is:\n\\[\nf_{\\text{scan}}=\\frac{f_{\\text{clk}}}{2N}.\n\\]\nIn my current code \\(N=60{,}000\\), so\n\\[\nf_{\\text{scan}}=\\frac{6\\,\\mathrm{MHz}}{2\\cdot 60{,}000}\\approx \\mathbf{50\\ \\mathrm{Hz}}.\n\\]\n\n\nHDL overview (key excerpts)\n\ntop.sv\n\nHSOSC at 6 MHz, instantiates Dmux and SevenSeg, drives Sum = ~(Sw1 + Sw2).\n\nDmux.sv\n\nSegInput = (DivClk) ? Sw1 : Sw2;\n\nEn1 = ~DivClk; En2 = DivClk;\n\nCounter toggles DivClk at the chosen scan rate.\n\nSevenSeg.sv\n\n16‑entry case producing active‑LOW segment patterns for 0x0–0xF (e.g., 4'b1001 /*9*/ → Seg=7'b0001100).\n\n\n\n\nUnit tests (simulation)\n\nSevenSeg_tb.sv (self‑checking): sweeps all 16 hex values and compares Seg to expected patterns.\n\ntop_tb.sv: iterates Sw1, Sw2 over 0x00–0xFF and checks Sum == ~(Sw1 + Sw2) and basic enable/segment sanity during scanning.\n\nDmux_tb.sv: spot‑checks scan duty and selection timing.\n\n\n\n\n\n\n\n\n\nFigure 2: SevenSeg waves across 0x0–0xF.\n\n\n\n\n\n\n\n\n\n\nFigure 3: SevenSeg transcript (1 expected X-case mismatch at vec 0).\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: top waves across 0x00–0xFF.\n\n\n\n\n\n\n\n\n\n\nFigure 5: top transcript (all pass)."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#electrical-design-red-led-current-calculations",
    "href": "labs/Lab 2/Lab2.html#electrical-design-red-led-current-calculations",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Electrical Design: red LED current calculations",
    "text": "Electrical Design: red LED current calculations\nThis display is common‑anode. Each segment has its own resistor and is sunk by an FPGA pin when ON (segment output = 0). The anode of the active digit is driven high via a PNP (2N3906). \n\nSegment resistor (per segment, \\(\\mathbf{R} = 240\\,\\Omega\\); common-anode, FPGA sinks)\nWith a PNP digit switch, the active digit’s anode is approximately \\(3.3 - V_{\\mathrm{CE,sat}}\\). The cathode path includes the LED and the FPGA’s \\(V_{\\mathrm{OL}}\\).\n\\[\nV_{\\mathrm{R}} = (3.3 - V_{\\mathrm{CE,sat}}) - V_{\\mathrm{F}} - V_{\\mathrm{OL}}, \\qquad\nI_{\\mathrm{seg}} = \\frac{V_{\\mathrm{R}}}{R_{\\mathrm{seg}}}.\n\\]\nUse conservative bounds \\(V_{\\mathrm{CE,sat}} \\approx 0.25\\,\\mathrm{V}\\) (2N3906) and Table 4.13 limits for \\(V_{\\mathrm{OL}}\\).\nTypical case (\\(V_{\\mathrm{F}} \\approx 1.8\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.2\\,\\mathrm{V}\\)): \\[\nV_{\\mathrm{R}} = 3.3 - 0.25 - 1.8 - 0.2 = 1.05\\,\\mathrm{V}, \\qquad\nI_{\\mathrm{seg}} = \\frac{1.05}{240} \\approx 4.38\\,\\mathrm{mA}.\n\\]\nConservative case (\\(V_{\\mathrm{F}} \\approx 2.0\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.4\\,\\mathrm{V}\\)): \\[\nV_{\\mathrm{R}} = 3.3 - 0.25 - 2.0 - 0.4 = 0.65\\,\\mathrm{V}, \\qquad\nI_{\\mathrm{seg}} = \\frac{0.65}{240} \\approx 2.71\\,\\mathrm{mA}.\n\\]\nBecause the display is multiplexed at ≈50 % duty, the average segment current is \\[I_{\\mathrm{seg,avg}} \\approx 0.5 \\cdot I_{\\mathrm{seg}}\\] ≈2.19 mA typical, ≈1.35 mA conservative.\n\n\n\nSolid stand-alone red LEDs (\\(\\mathbf{R} = 1\\,\\mathrm{k\\Omega}\\), FPGA sinks, no PNP)\nHere the resistor sees \\(V_{\\mathrm{R}} = 3.3 - V_{\\mathrm{F}} - V_{\\mathrm{OL}}\\).\nTypical (\\(V_{\\mathrm{F}} \\approx 1.8\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.2\\,\\mathrm{V}\\)): \\[I = \\frac{3.3 - 1.8 - 0.2}{1000} = \\frac{1.3}{1000} \\approx 1.30\\,\\mathrm{mA}.\\]\nConservative (\\(V_{\\mathrm{OL}} \\approx 0.4\\,\\mathrm{V}\\)): \\[I = \\frac{3.3 - 1.8 - 0.4}{1000} = \\frac{1.1}{1000} \\approx 1.10\\,\\mathrm{mA}.\\]\n\n\n\nPNP anode driver (per digit, \\(\\mathbf{R}_{\\mathrm{B}} = 1\\,\\mathrm{k\\Omega}\\))\nWorst-case segment load when displaying “8”: \\[I_{\\mathrm{C}} \\approx 7 \\cdot I_{\\mathrm{seg}}.\\]\nBase-resistor drop when ON: \\[V_{\\mathrm{RB}} \\approx V_{\\mathrm{E}} - V_{\\mathrm{BE,sat}} - V_{\\mathrm{OL}}.\\]\nWith \\(V_{\\mathrm{BE,sat}} \\approx 0.65\\text{–}0.85\\,\\mathrm{V}\\) and \\(V_{\\mathrm{OL}} \\approx 0.2\\text{–}0.4\\,\\mathrm{V}\\), \\[V_{\\mathrm{RB}} \\approx 3.3 - (0.65\\text{–}0.85) - (0.2\\text{–}0.4) \\approx 2.45\\text{–}2.05\\,\\mathrm{V}.\\]\nFor \\(R_{\\mathrm{B}} = 1\\,\\mathrm{k\\Omega}\\), \\[I_{\\mathrm{B}} \\approx \\frac{V_{\\mathrm{RB}}}{R_{\\mathrm{B}}} \\approx 2.05\\text{–}2.45\\,\\mathrm{mA}.\\]\nForced-beta check \\(\\beta_{\\mathrm{forced}} = I_{\\mathrm{C}} / I_{\\mathrm{B}}\\):\n\nTypical brightness (\\(I_{\\mathrm{seg}} \\approx 4.38\\,\\mathrm{mA}\\)):   \\(I_{\\mathrm{C}} \\approx 30.6\\,\\mathrm{mA}\\),   \\(\\beta_{\\mathrm{forced}} \\approx 12.5\\text{–}15\\).\nConservative brightness (\\(I_{\\mathrm{seg}} \\approx 2.71\\,\\mathrm{mA}\\)):   \\(I_{\\mathrm{C}} \\approx 19.0\\,\\mathrm{mA}\\),   \\(\\beta_{\\mathrm{forced}} \\approx 7.8\\text{–}9.3\\).\n\nThese values are suitable for saturating a 2N3906 in this current range."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#technical-documentation",
    "href": "labs/Lab 2/Lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nCode directory (this lab):\n\ntop.sv — top level (HSOSC @ 6 MHz, Dmux, SevenSeg, Sum LEDs)\nDmux.sv — divider + input select + digit enables\nSevenSeg.sv — hex→7‑segment decoder (active‑LOW)\n*_tb.sv — basic testbenches (SevenSeg_tb.sv, Dmux_tb.sv, top_tb.sv)\n\nTools: Radiant (synthesis, constraints, Netlist Analyzer), QuestaSim Lattice Edition (simulation).\n\n\nNotes that matter for this lab\n\nActive‑LOW segments. Common‑anode means driving a 0 turns a segment ON. Keep all case patterns consistent with this polarity.\nOne decoder only. Both digits share the same decoder → time‑multiplex inputs and enables.\nBrightness uniformity. Identical per‑segment resistors and a fixed 50% duty for each digit keep perceived brightness similar across numbers.\nScan rate. If you observe flicker or “ghosting,” increase \\(f_{\\text{scan}}\\) (reduce N)."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#results-discussion",
    "href": "labs/Lab 2/Lab2.html#results-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results & Discussion",
    "text": "Results & Discussion\n\nThe decoder produced the correct segment patterns for 0x0–0xF in simulation and on the physical board. The summing LED’s also followed the expected behavior.\n\nAt (N=60,000) (≈50 Hz scan), both digits are readable, with no visible flicker present.\nThe 5‑bit Sum LEDs matched Sw1 + Sw2 for all 256 input pairs in the top‑level test."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#conclusion",
    "href": "labs/Lab 2/Lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nI met the Lab 2 requirements: a single seven‑segment decoder time‑multiplexed across two digits, the sum on five LEDs, and current‑safe driving using PNP anode switches with per‑segment resistors. The design is modular (Dmux, SevenSeg, top) and synthesizes cleanly.\nTime spent: (8) hours."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#ai-implementation",
    "href": "labs/Lab 2/Lab2.html#ai-implementation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Implementation",
    "text": "AI Implementation\n\nPrompt used\n\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\n\n\nWhat the LLM produced\n\nGood ideas it used\n\nKept one hex→7-segment decoder and time-multiplexed the inputs (correct per spec).\nAdded a parameterized scan divider with $clog2 sizing and a clean always_ff counter.\nSplit the design into clear modules: a scan/mux block (selects nibble + digit enables) and the existing decoder.\nUsed always_comb for pure combinational logic and documented active-LOW segment polarity (common-anode).\nSuggested a sim mode with a tiny divider under ifndef SYNTHESIS to speed testbenches.\n\nGaps I had to fix\n\nThe first draft instantiated the decoder twice (one per digit). I rewired to feed a single decoder with the selected nibble.\nDigit enable polarity was backward for a PNP high-side scheme; I inverted the enables so only one anode is ON at a time.\n\n\n\n\nQuality rating (and why)\n\nRating: B+\nWhy: Architecture and modularity were solid, scan logic was close to correct, and it respected the “single decoder” objective after edits. Minor polarity mistakes and a comment/math mismatch kept it from an A.\n\n\n\nDid it synthesize first time?\n\nNot exactly. With the provided oscillator and decoder, it built after two small fixes:\n\nRemoved the duplicate decoder instance and fed the single instance from the scan mux.\n\nFlipped digit-enable polarity to match the common-anode via PNP wiring.\n\n\n\n\nWhat I’d do differently next time with an LLM\n\nPin down polarity & wiring in the prompt: “common-anode, active-LOW segments, PNP digit enables, single decoder” to avoid the duplicate-decoder and enable-polarity missteps.\n\nSpecify the exact primitives up front: “use the provided HSOSC and SegDisp modules by name” to prevent library/primitive swaps."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html",
    "href": "labs/Lab 1/Lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab I assembled the E155 development board, verified power rails, and brought up both the UPduino v3.1 FPGA (iCE40-UP5K) and the Nucleo-L432KC MCU. I then wrote SystemVerilog to (1) drive three LEDs per the given truth tables and (2) decode a 4-bit input from the on-board DIP switches (SW6) to a common-anode 7-segment display. The switches provide s[3:0] directly into the FPGA; the decoder drives seg[6:0] (active-low) through 1k ohm resistors to the display so that the selected hex digit lights correctly. Designs were simulated in QuestaSim, synthesized in Lattice Radiant, and programmed to the UP5K;"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#introduction",
    "href": "labs/Lab 1/Lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab I assembled the E155 development board, verified power rails, and brought up both the UPduino v3.1 FPGA (iCE40-UP5K) and the Nucleo-L432KC MCU. I then wrote SystemVerilog to (1) drive three LEDs per the given truth tables and (2) decode a 4-bit input from the on-board DIP switches (SW6) to a common-anode 7-segment display. The switches provide s[3:0] directly into the FPGA; the decoder drives seg[6:0] (active-low) through 1k ohm resistors to the display so that the selected hex digit lights correctly. Designs were simulated in QuestaSim, synthesized in Lattice Radiant, and programmed to the UP5K;"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#design-testing-methodology",
    "href": "labs/Lab 1/Lab1.html#design-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design & Testing Methodology",
    "text": "Design & Testing Methodology\n\nArchitecture\n\nInternal 48 MHz HSOSC feeds a power-on reset counter and a parameterized divider that creates a ~2.4 Hz tick for led[2].\nled_logic implements the required LED truth tables and optional active-low polarity.\nSevenSeg is a combinational hex→segments decoder with active-low outputs (for a common-anode display).\n\n\n\n\n\n\n\nFigure 1: Block diagram of the top-level (sbf_lab1).\n\n\n\n\n\nUnit tests (simulation)\nSelf-checking testbenches read .tv vectors: - tb_SevenSeg_tv verifies the 0x0–0xF map. - tb_led_logic_tv checks both active-high and active-low instances. - tb_lab1_sbf_tv checks seg and led[1:0] at top level (blink bit ignored).\n\nOn the single “error”: one vector intentionally contains unknowns (xxxxxxx) to represent a “don’t-care” state during initialization. The testbench expects xxxxxxx, while real hardware (with pull-ups and reset) resolves to 1111111 (all segments off). Functionally correct; the failure is in the expected vector, not the DUT.\n\n\n\nHardware bring-up\n\nVerified +5 V and +3.3 V LDO outputs on VIN power before inserting modules.\nWired one side of the dual 7-segment (common-anode) with series resistors on each segment; anode to 3.3 V.\nUsed ~1 kΩ series resistors → ≈3.3 mA/segment (ignoring LED (V_f)), comfortably within limits: [ I = 3.3  ]\n\n\n\n\n\n\n\nFigure 2: Hand-drawn schematic and current note (common-anode with ~1 kΩ resistors)."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#technical-documentation",
    "href": "labs/Lab 1/Lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nCode directory: https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201\n\nFPGA design: `sbf_lab1 (top).\nTestbenches: tb_all.sv.\n\nTools: Radiant (synthesis, constraints, Netlist Analyzer), QuestaSim Lattice Edition (simulation), SEGGER Embedded Studio (MCU).\n\n\nLED behavior specification\n\n\n\nS1\nS0\nled[0]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nON\n\n\n1\n0\nON\n\n\n1\n1\nOFF\n\n\n\n\n\n\nS3\nS2\nled[1]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nOFF\n\n\n1\n0\nOFF\n\n\n1\n1\nON\n\n\n\nled[2] blinks at ~2.4 Hz from the divider: \\[\n\\mathrm{TOGGLE\\_COUNT}\n= \\frac{48\\,\\mathrm{MHz}}{2 \\cdot 2.4\\,\\mathrm{Hz}} - 1\n= 10{,}000{,}000 - 1\n\\]\n\n\nSeven-segment notes\n\nCommon-anode display → active-low segment lines (0 turns a segment on).\nNaming: seg[0]=A … seg[6]=G.\nTo turn on correct segments:"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#results-discussion",
    "href": "labs/Lab 1/Lab1.html#results-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results & Discussion",
    "text": "Results & Discussion\n\nSeven-segment unit tests\n\n\n\n\n\n\n\n\nFigure 3: SevenSeg waves across 0x0–0xF.\n\n\n\n\n\n\n\n\n\n\nFigure 4: SevenSeg transcript (1 expected X-case mismatch at vec 0).\n\n\n\n\n\n\n\nLED logic unit tests\n\n\n\n\n\n\n\n\nFigure 5: LED logic waves (active-high and active-low instances).\n\n\n\n\n\n\n\n\n\n\nFigure 6: LED logic transcript (all pass).\n\n\n\n\n\n\n\nTop-level simulation\n\n\n\n\n\n\n\n\nFigure 7: Top-level (sbf_lab1) QuestaSim waves sweeping s=0..F.\n\n\n\n\n\n\n\n\n\n\nFigure 8: Top-level transcript (1 error corresponds to X-expectation init vector).\n\n\n\n\n\nInterpretation.\n- led_logic passes all vectors for both polarities.\n- SevenSeg and top-level each show one flagged vector where the testbench expects unknowns; hardware resolves to all off (1111111). Functionality is correct; the discrepancy is only in the expected file’s init case.\n- Divider math and POR behavior match intent; led[2] toggles at the expected rate (simulation time scaled)."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#conclusion",
    "href": "labs/Lab 1/Lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nI assembled and powered the E155 dev board, verified MCU↔︎FPGA connectivity, and implemented the required FPGA logic: LED truth tables, a ~2.4 Hz blink, and a combinational 7-segment decoder for a common-anode display. Simulation, synthesis, and on-board testing confirm correct behavior. The lone “failure” in automated tests is a deliberate X-expectation vector that resolves to “all off” in hardware.\nTime spent: 20 hours."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#all-code-httpsgithub.coms4anti4goe155treemainfpgaradiantprojectlab201",
    "href": "labs/Lab 1/Lab1.html#all-code-httpsgithub.coms4anti4goe155treemainfpgaradiantprojectlab201",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "All Code https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201",
    "text": "All Code https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#ai-implementation",
    "href": "labs/Lab 1/Lab1.html#ai-implementation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Implementation",
    "text": "AI Implementation\n\nPrompt\n\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nWhat the LLM produced (Gemini)\nGood ideas it used: - Parameterized divider (CLK_FREQ, BLINK_FREQ) with $clog2 sizing - Modern SV constructs (logic, always_ff) - Clear split: top module that wraps an oscillator primitive + a blinker child\nTop-level snippet returned (abridged): module led_blink_top (output logic o_led); logic clk_48mhz; SB_HFOSC u_hfosc ( .CLKHFPU(1’b1), .CLKHFEN(1’b1), .CLKHF(clk_48mhz) ); defparam u_hfosc.CLKHF_DIV = “0b00”; // 48 MHz led_blinker u_led_blinker (.clk(clk_48mhz), .led(o_led)); endmodule\n\n\nSynthesis outcome\nRadiant failed at the oscillator instantiation with: VERI-1063: instantiating unknown module SB_HFOSC Root cause: Radiant’s iCE40 UltraPlus technology library expects the HSOSC primitive, not SB_HFOSC (the SB_* form is common in iCEcube2 examples).\nFix applied (works in Radiant): // iCE40UP internal HF oscillator HSOSC #(.CLKHF_DIV(2’b00)) // 00 = 48 MHz hf_osc (.CLKHFPU(1’b1), .CLKHFEN(1’b1), .CLKHF(clk));\nI also replaced the LLM’s initial-based register inits with a tiny synchronous power-on reset (POR) counter so hardware powers up in a known state.\n\n\nQuality rating (and why)\n\nRating: B\n\nStrengths: idiomatic SV, readable, correct divide-by-N math, parameterized for reuse\n\nWeak spots: vendor primitive mismatch (SB_HFOSC vs HSOSC), defparam string style (\"0b00\"), reliance on initial for synthesis reset\n\n\n\nWhat I learned / new constructs\n\n$clog2 is handy for auto-sizing counters and synthesizes cleanly on UP5K.\nParameterizing the blink frequency made switching between 2 Hz (prompt) and 2.4 Hz (lab) a one-line change.\n\n\n\nErrors & warnings encountered\n\nRadiant: VERI-1063 instantiating unknown module SB_HFOSC → resolved by switching to HSOSC #(.CLKHF_DIV(2'b00)) and wiring CLKHFPU/CLKHFEN/CLKHF.\n\n\n\nTips for using LLMs for HDL (next-time playbook)\n\nSpecify tool, family, and exact primitive in the prompt: target Lattice Radiant for iCE40 UltraPlus (UP5K) and instantiate HSOSC (ports CLKHFPU, CLKHFEN, CLKHF; param CLKHF_DIV).\nAsk for a synthesizable reset: avoid initial; include a synchronous reset or a small POR counter.\nRequest a sim-friendly testbench: faster divider + self-check to validate logic quickly.\nAsk for Radiant-specific guidance: prefer Device Constraint Editor notes over generic .lpf.\nIterate with exact error text: paste Radiant/Questa messages back to the LLM for precise fixes.\n\n\n\nAppendix: Figure index\n\nBlock diagram: hmc-e155-portfolio/labs/Lab1/images/sv.jpg\n\nSchematic & current calc: hmc-e155-portfolio/labs/Lab1/images/elec.jpg\n\nTop-level waves: hmc-e155-portfolio/labs/Lab1/images/lab test waves.png, hmc-e155-portfolio/labs/Lab1/images/lab vectors.png\n\nLED unit waves: hmc-e155-portfolio/labs/Lab1/images/led test waves.png, hmc-e155-portfolio/labs/Lab1/images/led text tests.png\n\nSeven-seg waves: hmc-e155-portfolio/labs/Lab1/images/seven seg waves.png, hmc-e155-portfolio/labs/Lab1/images/seven seg tests.png"
  },
  {
    "objectID": "labs/Lab 3/Lab3.html",
    "href": "labs/Lab 3/Lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab I designed and verified a 4×4 matrix keypad scanner on an iCE40 FPGA. The design registers each key exactly once (on press), filters bounce, ignores additional keys while one is held, and displays the last two hex digits on a dual common-anode seven-segment display (most recent on the right). The keypad orientation is aligned with the display.\n\nDisplay polarity. Common-anode → Seg[6:0] are active-LOW and digit enables select which anode is active."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#introduction",
    "href": "labs/Lab 3/Lab3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab I designed and verified a 4×4 matrix keypad scanner on an iCE40 FPGA. The design registers each key exactly once (on press), filters bounce, ignores additional keys while one is held, and displays the last two hex digits on a dual common-anode seven-segment display (most recent on the right). The keypad orientation is aligned with the display.\n\nDisplay polarity. Common-anode → Seg[6:0] are active-LOW and digit enables select which anode is active."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#system-overview",
    "href": "labs/Lab 3/Lab3.html#system-overview",
    "title": "Lab 3: Keypad Scanner",
    "section": "System Overview",
    "text": "System Overview\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram.\n\n\n\n\n\nTop-Level Architecture\n\nClocking: Lattice HSOSC at ~6 MHz (CLKHF_DIV=2'b11).\nKeypad interface:\n\nRows (Row[3:0]) are FPGA outputs, one row driven LOW at a time (scan).\nColumns (Col[3:0]) are FPGA inputs with pull-ups (PULLMODE=UP). A pressed key shorts the active low row to its column → that column reads 0.\n\nScanner (KeypadScan):\n\nRound-robin row scan (≈2 kHz), 2-FF synchronizers on Col[3:0].\nFSM with states IDLE → DEB → HELD.\n\nOn first detection, freeze the candidate row/col and debounce for a few scan ticks.\nEmit a 1-cycle key_valid on acceptance, then ignore other keys until all columns return high.\n\n\nDisplay path: On key_valid, shift {D_left, D_right} ← {D_right, key_code}. A single SevenSeg instance decodes the selected nibble; DMux alternates enables (En1, En2) and feeds the decoder input (s) at a fixed duty to avoid brightness variation.\n\n\n\n\n\n\n\nFigure 2: RTL"
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#state-machine-specification",
    "href": "labs/Lab 3/Lab3.html#state-machine-specification",
    "title": "Lab 3: Keypad Scanner",
    "section": "State Machine Specification",
    "text": "State Machine Specification\n\nState Diagram\n\n\n\n\n\n\nFigure 3: FSM"
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#state-transition-table",
    "href": "labs/Lab 3/Lab3.html#state-transition-table",
    "title": "Lab 3: Keypad Scanner",
    "section": "State Transition Table",
    "text": "State Transition Table\n\nIDLE – transitions\n\n\n\n\n\n\n\n\n\nCurrent State\nCondition (plain English)\nNext State\nNotes\n\n\n\n\nIDLE\nA key seems pressed (while scanning, some column reads LOW)\nDEB\nLatch the candidate key = (active row, first LOW column); compute hex\n\n\nIDLE\nOtherwise\nIDLE\nContinue round-robin row scan\n\n\n\n\n\nDEB – transitions\n\n\n\n\n\n\n\n\n\nCurrent State\nCondition (plain English)\nNext State\nNotes\n\n\n\n\nDEB\nAll columns are HIGH again (looks like release or a glitch)\nIDLE\nAbort debounce; resume scanning\n\n\nDEB\nOn the scan strobe, the same candidate column is still LOW and the stable count just reached the target (e.g., 3 in a row)\nHELD\nAccept the key; emit a one-clock key_valid pulse\n\n\nDEB\nOn the scan strobe, the same candidate column is still LOW but the stable count hasn’t reached the target\nDEB\nKeep counting consecutive stable observations\n\n\nDEB\nOn the scan strobe, the candidate column is not LOW\nDEB\nReset the stable counter to zero\n\n\nDEB\nOtherwise\nDEB\nKeep the candidate row held LOW and wait for next scan strobe\n\n\n\n\n\nHELD – transitions\n\n\n\n\n\n\n\n\n\nCurrent State\nCondition (plain English)\nNext State\nNotes\n\n\n\n\nHELD\nAll columns are HIGH (the key has been fully released)\nIDLE\nReturn to scanning; allow a new key\n\n\nHELD\nOtherwise (key still held, or other keys also pressed)\nHELD\nIgnore additional keys until full release\n\n\n\n\n\nOutputs & Actions (per state)\n\n\n\n\n\n\n\n\n\nState\nRow Drive (what we drive on the keypad)\nRegisters / Counters (what we latch/update)\nOne-Cycle Outputs\n\n\n\n\nIDLE\nRound-robin: one row LOW at a time (…1110 → 1101 → 1011 → 0111…)\nOn first LOW column: latch candidate row & column, compute and hold candidate hex, clear stable counter\nkey_valid = 0\n\n\nDEB\nFreeze: keep only the candidate row LOW\nOn each scan strobe: if same column still LOW → increment stable counter; else reset to 0\nWhen target count reached on a strobe: key_valid = 1 (one clock)\n\n\nHELD\nFreeze: keep only the candidate row LOW\nWait until all columns HIGH (full release); counters unchanged\nkey_valid = 0\n\n\n\n\nMini-glossary (for the table)\n\nScan strobe: periodic tick that advances row scan and paces debouncing.\nCandidate key: first detected (row, column) pair; row is held during debounce.\nStable count: number of consecutive scan strobes where that same column remains LOW (target e.g. 3).\nAll columns HIGH: no key asserted (1111 due to pull-ups).\n\n\n\n\n\nOne-liners for implementation cross-check\n\nAccept press when: state==DEB && scan_tick && stable_cand && deb_cnt==N_stable-1 → key_valid&lt;=1, state&lt;=HELD.\nAbort bounce when: state==DEB && all_released → deb_cnt&lt;=0, state&lt;=IDLE.\nIgnore additional keys while HELD: do nothing until all_released."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#debouncing-metastability",
    "href": "labs/Lab 3/Lab3.html#debouncing-metastability",
    "title": "Lab 3: Keypad Scanner",
    "section": "Debouncing & Metastability",
    "text": "Debouncing & Metastability\n\nSynchronizers: Each Col[x] passes through a two-flip-flop chain (col_s1 → col_sync) clocked at 6 MHz to mitigate metastability.\nDebounce window: Acceptance requires three stable observations of the candidate column under a frozen row. This balances responsiveness and immunity to mechanical bounce.\nSingle-event guarantee: key_valid is generated once, on the press edge only. While in HELD, new presses are ignored until release."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#timing-multiplexing",
    "href": "labs/Lab 3/Lab3.html#timing-multiplexing",
    "title": "Lab 3: Keypad Scanner",
    "section": "Timing & Multiplexing",
    "text": "Timing & Multiplexing\n\nScan Timing\nA 13-bit divider creates a ~2 kHz scan tick. Rows step: 1110 → 1101 → 1011 → 0111. The debounce counter advances only on scan ticks. Timing can be seen on top Module Wave form.\n\n\nDisplay Timing (DMux)\nDMux toggles a digit select at ~50 Hz (counter=60 000 at 6 MHz → 50 Hz).\n\ns = (DivClk) ? D_right : D_left\nEn2 = DivClk, En1 = ~DivClk\nConstant duty keeps brightness uniform, independent of the number of lit segments.\n\nTiming can be seen on top Module Wave form."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#pinout-orientation",
    "href": "labs/Lab 3/Lab3.html#pinout-orientation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Pinout & Orientation",
    "text": "Pinout & Orientation\n\nRows (outputs): connect to keypad R0..R3.\nColumns (inputs w/ pull-up): connect to keypad C0..C3.\nThe map_hex table encodes the keypad legend for (row, col) indices consistent with the chosen orientation.\n\n\n\n\n\n\n\nFigure 4: Layout Schematic"
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#hdl-summary-files-roles",
    "href": "labs/Lab 3/Lab3.html#hdl-summary-files-roles",
    "title": "Lab 3: Keypad Scanner",
    "section": "HDL Summary (files & roles)",
    "text": "HDL Summary (files & roles)\n\ntop.sv — HSOSC, KeypadScan, capture registers for last two digits, DMux, SevenSeg.\nKeypadScan.sv — row scan, 2-FF input sync, IDLE/DEB/HELD FSM, map_hex(r,c).\nDMux.sv — display multiplexer + digit enables (fixed duty).\nSevenSeg.sv — combinational hex→segments (active-LOW).\n\nAll combinational logic is in always_comb; sequential is in always_ff with a single driver per reg (no latches, no tri-states)."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#simulation-verification",
    "href": "labs/Lab 3/Lab3.html#simulation-verification",
    "title": "Lab 3: Keypad Scanner",
    "section": "Simulation & Verification",
    "text": "Simulation & Verification\n\nTestbench Strategy\n\nA behavioral keypad model drives Col[3:0] LOW only when the DUT selects the matching row LOW.\nThe TB issues a sequence of 16 keys (walks the matrix), waits for key_valid, and then checks the two displayed digits by sampling when each enable is active.\nNegative tests:\n\nHold one key, “press” another → verify the second is ignored until release.\nInject brief bounces on a column line → ensure single registration.\n\n\n\n\n\n\n\n\n\n\nFigure 5: Keypad Scan, Dmux, and Top waveforms.\n\n\n\n\n\n\n\n\n\n\nFigure 6: waveform transcript (1 expected X-case mismatch at vec 0).\n\n\n\n\n\n\n\nResults (simulation)\n\nEach programmed key press produced one key_valid pulse and the expected key_code.\nWith one key held, additional simulated presses did not register.\nDisplay sampling showed stable, non-flickering output; both digits had equal duty."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#hardware-bring-up-measurements",
    "href": "labs/Lab 3/Lab3.html#hardware-bring-up-measurements",
    "title": "Lab 3: Keypad Scanner",
    "section": "Hardware Bring-Up & Measurements",
    "text": "Hardware Bring-Up & Measurements\n\nVerified with a multimeter that each button shorts exactly one Row to one Col (&lt;100 Ω) and that Col idles at 1111 with no key (internal pull-ups).\nConfirmed row order and column order match the map_hex orientation by observing a temporary LED debug (~Row, ~Col) and adjusting constraints where needed.\nFinal board test: pressing any key updates the right digit; the previous right digit shifts to the left. Press-and-hold does not cause repeats; additional presses are ignored until release."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#design-tradeoffs-alternatives",
    "href": "labs/Lab 3/Lab3.html#design-tradeoffs-alternatives",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design Tradeoffs & Alternatives",
    "text": "Design Tradeoffs & Alternatives\n\nDebounce length: I chose 3 scan-ticks (≈1.5 ms at ~2 kHz) for a good balance of responsiveness vs. bounce immunity. Longer windows reduce false triggers but feel less snappy.\nScan rate: ~2 kHz row stepping comfortably exceeds bounce dynamics and avoids aliasing; slower scanning risks missing very short taps.\nSingle decoder + mux: Minimizes area and guarantees identical glyphs; the tradeoff is a need for careful duty control to keep brightness uniform.\nFirst-press policy vs. NKRO: For a diode-less matrix, “first-press wins” avoids ghosting; true multi-key (NKRO) would require per-switch diodes or a more complex detection + ghost-masking strategy.\nSynchronizers: 2-FF is sufficient at 6 MHz; 3-FF would further reduce MTBF at the cost of extra latency."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#schematic-notes",
    "href": "labs/Lab 3/Lab3.html#schematic-notes",
    "title": "Lab 3: Keypad Scanner",
    "section": "Schematic Notes",
    "text": "Schematic Notes\n\nColumns: inputs with PULLMODE=UP\nRows: push-pull outputs; one driven LOW at a time.\nDisplay: common-anode; segment resistors per segment; enables at constant duty."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#conclusions",
    "href": "labs/Lab 3/Lab3.html#conclusions",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusions",
    "text": "Conclusions\nThe implemented keypad scanner meets the lab requirements:\n\nCorrectly reads the 4×4 keypad, debounces, and registers once per press.\nIgnores additional keys while one is held.\nDrives the dual 7-segment display with stable brightness and correct ordering (most-recent on right).\nUses clean, latch-free, tri-state-free RTL with proper synchronizers.\n\nTime spent: (12 hours). Known limitations / future work:\n\nAdd a compile-time option to speed the scan/dividers in simulation.\nAuto-detect row/col orientation at power-up to reduce pin-map bring-up friction."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#appendix",
    "href": "labs/Lab 3/Lab3.html#appendix",
    "title": "Lab 3: Keypad Scanner",
    "section": "Appendix",
    "text": "Appendix\n\nFile List\ntop.sv\nKeypadScan.sv\nDMux.sv\nSevenSeg.sv\nhsosc_sim.sv   // simulation model only\n*_tb.sv        // keypad + display testbenches\n\n\nKey Equations\n\nDisplay scan: \\(f_{\\text{scan}} = \\dfrac{f_{\\text{clk}}}{2N}\\) (N = DMux terminal count).\nDebounce window: \\(T_{\\text{deb}} = N_{\\text{stable}} / f_{\\text{row-scan}}\\)."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#ai-implementation",
    "href": "labs/Lab 3/Lab3.html#ai-implementation",
    "title": "Lab 3: Keypad Scanner",
    "section": "AI Implementation",
    "text": "AI Implementation\n\nPrompt used\n\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4×4 matrix keypad and display the last two hex keys pressed on a dual 7-segment display. Implement: • A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. • A keypad scanning controller that iterates one active-low column at a time and samples active-low rows, registering at most one key per press (debounce-by-design), ignoring additional presses while any key is held, and allowing a new registration only after release. • A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time-multiplexed two-digit 7-segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices. Create a new Radiant project, type the code generated by the LLM in and analyze the results. If the synthesis fails, type the error message back into the LLM to see what suggestions it generates.\n\n\n\nWhat the LLM produced\n\nGood ideas it used\n\nClear module split: KeypadScan (scanner + debounce FSM), DMux (digit scan/mux), SevenSeg (combinational hex→segments), top (capture two digits, wire-up).\nSynchronous FSM with three states (IDLE → DEB → HELD), a one-shot key_valid pulse on accept, and two-flip-flop synchronizers on the asynchronous column inputs.\nRound-robin row drive and frozen row during debounce, which prevents ghosting and enforces “first press wins.”\nTime-multiplexed display with fixed duty for uniform brightness, and active-LOW segment patterns for a common-anode display.\nIncluded a scan tick to pace debounce (stable-N policy), keeping all counters/sequencing in always_ff and decoding in always_comb.\n\nGaps I had to fix\n\nRow/column polarity & direction: the prompt assumed active-low columns and sampled rows, but our board drives rows (active-LOW) and reads columns (with pull-ups). I corrected the interface and comments to match hardware.\nKey mapping: the default (row,col)→hex map didn’t match the physical keypad legend; I rewrote map_hex to our layout.\nMultiple drivers risk: key_valid was assigned in more than one procedural context in one draft. I consolidated to a single always_ff.\nDebounce edge case: the counter was clocked every system cycle; I tied it to the scan strobe so stability is measured per row sample.\nSimulation speed: initial dividers made sims painfully long; I added small counts under a guarded sim mode while leaving hardware rates intact.\n\n\n\n\nQuality rating (and why)\n\nRating: A-\nWhy: The LLM delivered a solid modular architecture and a correct synchronous FSM with proper input synchronization and single-event registration. Most fixes were integration details (board polarity, key legend, divider sizing) rather than structural rewrites.\n\n\n\nDid it synthesize first time?\n\nAlmost. It compiled after minor edits:\n\nAlign row/column direction and polarity with our board.\nFix a single-writer rule on key_valid.\nAdjust the (row,col)→hex lookup to the actual keypad legend.\nTweak divider constants (fast for sim, slow for hardware) and confirm no latches/tri-states.\n\n\n\n\nWhat I’d do differently next time with an LLM\n\nState the physical contract explicitly in the prompt: “Rows = outputs, active-LOW; Columns = inputs with pull-ups (idle=1111); Segments active-LOW; digit enables En1/En2 select left/right.”\nProvide the keypad legend and pin swap up front and ask the model to generate map_hex from a small (row,col)→label table.\nAsk for +ifdef SIM dividers from the start to keep waveforms short and readable.\nRequire one-process-per-reg and “no $clog2/parameters” if a strict style is desired, so the draft matches house style without edits."
  },
  {
    "objectID": "posts/FirstPost.html",
    "href": "posts/FirstPost.html",
    "title": "First Post!",
    "section": "",
    "text": "I’m excited for MicroPs because I get to see my code affect hardware in the real world. Writing something, probing a pin, and watching the scope confirm it did what I intended is the kind of feedback loop that makes the work satisfying and helps me absorb information.\nThis semester I want to build fluency in the basics that make systems reliable: read reference manuals without getting stuck, set up clocks cleanly, bring up GPIO/timers/serial, and write small drivers with clear init and ISR paths. I want to use interrupts and DMA with intent, understand when HAL or an RTOS helps (and when it doesn’t), and get better at debugging with a logic analyzer and scope instead of guessing.\nBy the end, I’m excited to be able to partake in a focused project I care about that uses the information I learned from the class. Looking forward to it :D"
  },
  {
    "objectID": "resources/resource1.html",
    "href": "resources/resource1.html",
    "title": "E155 Course Page",
    "section": "",
    "text": "https://hmc-e155.github.io"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! I’m Santiago Burgos-Fallon, a senior Engineering student at Harvey Mudd College. I love everything computers, from digital design and embedded systems to data analysis. This summer I worked at TSMC in Lithography Process Engineering, where I analyzed overlay relationships, tuned control systems, and pushed on design-for-manufacturability to improve chip yield and performance. Ive built practical digital systems including a 16 bit IEEE-754 FMA and a drone navigation project that fuses computer vision with ultra-wideband (UWB) positioning. Ive also done work relating healthcare tooling and AI for making healthcare more accesible. Currently, I am co-authoring a paper using Python-heavy data processing and visualization techniques to correlate air quality and Segregation in West Oakland. I like projects where I can go end-to-end: define the problem, model the data, write the code, and deliver something impactful."
  },
  {
    "objectID": "Resources.html",
    "href": "Resources.html",
    "title": "Resources",
    "section": "",
    "text": "MAN 6400 Data Sheet\n\n\nhttps://hmc-e155.github.io/assets/doc/MAN64x0%20Series.pdf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE155 Course Page\n\n\nWhat the title says\n\n\n\n\n\n\n\n\nNo matching items"
  }
]