[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "First Post!\n\n\nWhat Im looking forward to in Micro P’s\n\n\n\n\n\nAug 29, 2024\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "final project/Ddrum.html",
    "href": "final project/Ddrum.html",
    "title": "Final Project: DDRUM",
    "section": "",
    "text": "Team Members:\nSantiago Burgos-Fallon: A senior Engineering student at Harvey Mudd College. Passionate about everything computers, from digital design and embedded systems to data analysis. This summer he worked at TSMC in Lithography Process Engineering, where he analyzed overlay relationships, tuned control systems, and pushed on design-for-manufacturability to improve chip yield and performance. Additionally he has built practical digital systems including a 16 bit IEEE-754 FMA and a drone navigation project that fuses computer vision with ultra-wideband (UWB) positioning. - Portfolio\nAbraham Rock: An Engineering student at Harvey Mudd College in the Class of 2027. His interests lie in digital electronics, embedded systems, and systems engineering. He is in the ASHMC Executive Board where he acts as this year’s Muddlife Director. - Portfolio\nAbstract: DDRUM is an embedded rhythm game system that integrates real-time audio processing, custom hardware inputs, and high-speed visual feedback. The system utilizes an STM32L432KC microcontroller for audio streaming, beat detection, and synchronization, reading uncompressed WAV files from an SD card and buffering them to create a precise “lookahead” mechanic. An iCE40UP5K FPGA acts as a parallel graphics accelerator, driving a 64x64 HUB75 LED matrix with 24-bit color via Binary Code Modulation (BCM) while simultaneously handling input from four custom piezoelectric drum pads with zero-latency debounce logic. By decoupling audio analysis from visual rendering across two distinct processors communicating via SPI, DDRUM achieves fluid, high-refresh rate visuals and accurate rhythm scoring without the overhead of an operating system.\nProject Demonstration:"
  },
  {
    "objectID": "final project/Ddrum.html#abstract-team",
    "href": "final project/Ddrum.html#abstract-team",
    "title": "Final Project: DDRUM",
    "section": "",
    "text": "Team Members:\nSantiago Burgos-Fallon: A senior Engineering student at Harvey Mudd College. Passionate about everything computers, from digital design and embedded systems to data analysis. This summer he worked at TSMC in Lithography Process Engineering, where he analyzed overlay relationships, tuned control systems, and pushed on design-for-manufacturability to improve chip yield and performance. Additionally he has built practical digital systems including a 16 bit IEEE-754 FMA and a drone navigation project that fuses computer vision with ultra-wideband (UWB) positioning. - Portfolio\nAbraham Rock: An Engineering student at Harvey Mudd College in the Class of 2027. His interests lie in digital electronics, embedded systems, and systems engineering. He is in the ASHMC Executive Board where he acts as this year’s Muddlife Director. - Portfolio\nAbstract: DDRUM is an embedded rhythm game system that integrates real-time audio processing, custom hardware inputs, and high-speed visual feedback. The system utilizes an STM32L432KC microcontroller for audio streaming, beat detection, and synchronization, reading uncompressed WAV files from an SD card and buffering them to create a precise “lookahead” mechanic. An iCE40UP5K FPGA acts as a parallel graphics accelerator, driving a 64x64 HUB75 LED matrix with 24-bit color via Binary Code Modulation (BCM) while simultaneously handling input from four custom piezoelectric drum pads with zero-latency debounce logic. By decoupling audio analysis from visual rendering across two distinct processors communicating via SPI, DDRUM achieves fluid, high-refresh rate visuals and accurate rhythm scoring without the overhead of an operating system.\nProject Demonstration:"
  },
  {
    "objectID": "final project/Ddrum.html#system-overview",
    "href": "final project/Ddrum.html#system-overview",
    "title": "Final Project: DDRUM",
    "section": "2. System Overview",
    "text": "2. System Overview\nDDRUM is a four-pad rhythm game in the spirit of DDR and Guitar Hero. Notes descend in four lanes on a display while a song plays. The player strikes one of four drum pads on the beat, and the system scores accuracy as Perfect, Okay, or Miss with real-time visual feedback and a running score/combo.\n\nHigh Level Block Diagram\n\nBlock Diagram"
  },
  {
    "objectID": "final project/Ddrum.html#hardware-design-schematics",
    "href": "final project/Ddrum.html#hardware-design-schematics",
    "title": "Final Project: DDRUM",
    "section": "3. Hardware Design & Schematics",
    "text": "3. Hardware Design & Schematics\n\nBill of Materials\n\n\n\nItem\nQty\nPrice\nSource\nPart Number / Notes\n\n\n\n\n64×64 RGB LED Matrix (HUB75)\n1\n$36.59\nAmazon\nP3.0 Panel\n\n\nPiezo Disc Transducers\n15\n$6.49\nAmazon\n27 mm Piezo Discs\n\n\nMicro SD Card Reader\n1\n$0.00\nEngineering Stockroom\nTeensy Brand (Unknown P/N)\n\n\nICE40UP5K-SG48I FPGA\n1\nIncluded\nIncluded with Ps kit\nICE40UP5K-SG48I\n\n\nSTM32L432KCU MCU\n1\nIncluded\nIncluded with Ps kit\n\n\n\n\n\n\nNew Hardware Description\nPiezoelectric Transducers & Analog Front End: The Piezo discs are small sensors that generate electrical charge from mechanical stress. Looking at the raw oscilloscope traces of the sensors, these are very sensitive sensors that can vary heavily in output, capable of producing a signal over 15 V in amplitude. To protect our FPGA IOs and to ensure loading doesn’t ruin the signal, we ran it through a unity gain buffer Op-Amp to potentially rail out and get the output signal to a safe voltage (3.3 V).\n\n\n\n\n\nPiezo Trace 1\n\n\nRaw Signal 1\n\n\n\n\nPiezo Trace 2\n\n\nRaw Signal 2\n\n\n\n\nPiezo Setup\n\n\nRaw Signal 3\n\n\nFigure 1: Oscilloscope analysis of the Piezoelectric transducers showing the voltage spikes and the buffering circuit.\nHUB75 LED Matrix: The 64x64 RGB LED Matrix is a high-density display that utilizes the HUB75 interface. Unlike the SPI-based LCDs used in previous course labs which possess internal RAM and controllers, this panel is a “dumb” display that requires continuous, high-speed driving of its shift registers and row select lines to maintain an image. Since the LEDs are purely digital (on/off), we utilized the FPGA to implement Binary Code Modulation (BCM)—rapidly modulating the specific on-times of the LEDs—to achieve full 24-bit color depth without utilizing a specialized driver chip.\nMicro SD Card Reader: To store the high-fidelity audio tracks for the game, we utilized a Micro SD Card breakout board. This module interfaces with the STM32 via the SPI protocol (Mode 0) running at 2.5 MHz. Unlike the internal flash memory on the MCU, which is limited in size, the SD card allows us to store large, uncompressed .wav files. We implemented a read-only FAT32 file system driver to locate the target song files and stream data in 512-byte sectors into the MCU’s circular buffer for processing.\n\n\nSchematic\n\n\n\nMain Schematic\n\n\nFigure 2: Main System Schematic."
  },
  {
    "objectID": "final project/Ddrum.html#microcontroller-design",
    "href": "final project/Ddrum.html#microcontroller-design",
    "title": "Final Project: DDRUM",
    "section": "4. Microcontroller Design",
    "text": "4. Microcontroller Design\nOur Microcontroller is functioning as the central controller. It is responsible for playing audio, analyzing the music data to generate beats, and synchronizing audio playback with the FPGA’s visual elements.\nTo read in the music data, we use a Micro SD Card Reader acting as a peripheral where we read a .wav file from the SD card 512 bytes at a time.\n\n\n\nSPI SD Card Trace\n\n\nFigure 3: Logic analyzer trace of SPI communication between MCU and SD Card.\nFor most rhythm games — including our own, a major part is displaying the beats from the song before they are played. Since we chose a fall time of 2 seconds for the visual logic on our FPGA, we needed to buffer the output by exactly 2 seconds to make the beat info sent to the FPGA match up. To do this, after reading in a sector, we analyze it immediately, save it into a circular RAM buffer, and then later use the DAC peripheral to play that audio cleanly.\nTo determine what is a valid beat in the song, we considered analyzing the frequency of a chunk of the song via an FFT and considering low enough frequencies as bass/drum beats. However, we realized frequency analysis alone would not function well as real beats are a complex combination of frequency, volume, and transient attack, making it a challenge for even sophisticated neural networks.\nSo we decided that to be more efficient and save us the time of implementing an FFT accelerator, we solely consider volume dynamics. We calculated the average volume of the song as we read it in via a simple integrator to track the running average of the song’s energy; if a sample’s amplitude spikes 20% higher than this average, we register it as a beat.\nOnce a beat is identified, we communicate with the FPGA using the SPI peripheral. The FPGA shares the same SPI bus as the SD card but is addressed via a separate Chip Select pin. We simply assert the line, transmit a single-byte bitmask indicating the active lane, and de-assert the line.\n\n\n\n\n\n2nd Lane Active\n\n\n2nd Lane Active\n\n\n\n\n4th Lane Active\n\n\n4th Lane Active\n\n\nFigure 4: Logic analyzer trace of SPI transaction sending beat mask from MCU to FPGA.\nFinally, for the audio output, we use the DAC driven by a hardware timer (TIM6). We configure the timer to trigger an interrupt at the exact sample rate of the file. On every tick, the handler pulls the “oldest” byte from the tail of our circular buffer and writes it to the DAC output register, ensuring the audio plays smoothly and in perfect sync with the visuals we triggered 2 seconds prior."
  },
  {
    "objectID": "final project/Ddrum.html#fpga-design",
    "href": "final project/Ddrum.html#fpga-design",
    "title": "Final Project: DDRUM",
    "section": "5. FPGA Design",
    "text": "5. FPGA Design\nOur FPGA functions as a graphics processor and keeps track of the game logic. While the MCU handled high-level audio processing, we used our FPGA to drive the LED Matrix quickly, track falling notes, and handle drum beat inputs all in parallel.\n\nRTL Hierarchy\n\n\n\nGenerated Hierarchy\n\n\nFigure 5: Generated Hierarchy Diagram with TerosHDL\n\n\n\nBlock Diagram\n\n\nFigure 6: Block Diagram of RTL Structure.\nThe FPGA is an SPI peripheral for the MCU, waiting for chip select to drop so it can shift in a beat byte to iwnterpret which lane it should display on the LED Matrix. To prevent metastability between the crossing clock domains of the SPI Clock and its primitive HFOSC, we have the inputs go through a two-layer shift register to synchronize new beats safely.\nThe core gameplay is all contained within the visual driving logic in the pattern_gen module. Each of the 4 lanes is a 64-bit shift register. When a beat arrives from the SPI interface, it simply travels through the shift register at a divided clock’s pace. For controlling all visual things including the “Hit Line,” we can simply check when and where a bit is in the shift register to tell if the hits we detect are “on time”.\nWe use our Piezoelectric Disc Transducers as buttons to detect impact from the user. While they inherently aren’t very bouncy like mechanical buttons, putting them in a 3D-Printed Drum Casing added some bounce during testing, so we used a debouncer module to mediate this with a 100ms lockout.\nThe most computationally expensive part of this design is driving the HUB75 and using Binary Coded Modulation (BCM). To prevent screen tearing (visual bleeding), we write the game data to a “back buffer” while the hub75_framebuffer module grabs data from the “front buffer” for display. Since the LED panels are purely digital (on/off), the BCM logic rapidly modulates the LEDs—turning them on for short intervals for LSBs and longer intervals for MSBs—to trick the eye into seeing full 24-bit color.\nFinally, to display the player’s progress, we implemented a font_rom that maps the current score to 5x3 pixel bitmaps, rendering them directly onto the matrix in real-time alongside the falling notes.\n\n\nVerification\nThe modules that we wrote were: top, pattern_gen, font_rom, debouncer, beat_reciever, hit_detector. Testbenches were written to test them individually.\n\nDebouncer:\n\nDebouncing Module\n\n\nPattern Generator:\n\nPattern Generator Module\n\n\nSPI Reciever (inst. as beat_detector):\n\nSPI Module\n\n\nDisplay Driver:\n\nDriver Module\n\n\nDisplay Memory:\n\nMemory Module"
  },
  {
    "objectID": "final project/Ddrum.html#results",
    "href": "final project/Ddrum.html#results",
    "title": "Final Project: DDRUM",
    "section": "6. Results",
    "text": "6. Results\nThe final DDRUM system met all design specifications, achieving fluid integration between the audio subsystem and the custom FPGA graphics accelerator. Audio Synchronization & Memory Management The system successfully implemented a 2.00-second lookahead buffer to facilitate beat detection. Given the STM32L432KC’s constraint of 64KB SRAM, we utilized 16 kHz, 8-bit mono audio. This configuration required approximately 44.1 KB of RAM for the 2-second window, leaving adequate headroom for the stack, heap, and file system drivers. The SD card throughput was measured at approximately 200 KB/s, easily sustaining the playback consumption rate of ~16 KB/s and preventing buffer underruns. Visual Refresh Rates The iCE40 FPGA successfully drove the HUB75 matrix using Binary Code Modulation (BCM) logic. We achieved a visual refresh rate of &gt;60 Hz with full 24-bit color depth (8 bits per channel). The dedicated hardware SPI interface handled the beat mask transfer with negligible latency (&lt; 1 \\(\\mu\\)s), ensuring the visual “hit line” remained perfectly aligned with the audible beat. Input Latency & Signal Integrity The piezoelectric analog front-end, combined with the Unity Gain Buffer, successfully clamped input voltages to the safe 0V–3.3V logic range. The hardware-based debouncer, tuned to a 10 ms lockout window, eliminated mechanical “ringing” from the sensor pads. This resulted in a clean, single trigger event per drum strike, removing false positives while maintaining a responsive feel for the player.\n \nFigure 7: The completed DDRUM system."
  },
  {
    "objectID": "final project/Ddrum.html#references-acknowledgements",
    "href": "final project/Ddrum.html#references-acknowledgements",
    "title": "Final Project: DDRUM",
    "section": "7. References & Acknowledgements",
    "text": "7. References & Acknowledgements\nReferences: no2fpga’s no2hub75 hardware implementation\nAcknowledgements: Thank you to Prof. Spencer for reigning in the expectations of this project and making it all possible. Thank you to the T.A.’s Neil and Troy for being a pillar of support for us and the whole class.\nAI Feedback and Usage: We used AI for help getting the DAC peripheral to work, and bug fixing and clarification for driving the HUB75 interface with our pattern_gen module. In our liminal testing we found ChatGPT to be more proficient with HDL and Gemini to be better at C."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! I’m Santiago Burgos-Fallon, a senior Engineering student at Harvey Mudd College. I love everything computers, from digital design and embedded systems to data analysis. This summer I worked at TSMC in Lithography Process Engineering, where I analyzed overlay relationships, tuned control systems, and pushed on design-for-manufacturability to improve chip yield and performance. Ive built practical digital systems including a 16 bit IEEE-754 FMA and a drone navigation project that fuses computer vision with ultra-wideband (UWB) positioning. Ive also done work relating healthcare tooling and AI for making healthcare more accesible. Currently, I am co-authoring a paper using Python-heavy data processing and visualization techniques to correlate air quality and Segregation in West Oakland. I like projects where I can go end-to-end: define the problem, model the data, write the code, and deliver something impactful."
  },
  {
    "objectID": "resources/resource1.html",
    "href": "resources/resource1.html",
    "title": "E155 Course Page",
    "section": "",
    "text": "https://hmc-e155.github.io"
  },
  {
    "objectID": "FinalProject.html",
    "href": "FinalProject.html",
    "title": "Final Project",
    "section": "",
    "text": "Final Project: DDRUM\n\n\nintegrates real-time audio processing, custom hardware inputs, and high-speed visual feedback.\n\n\n\n\n\nDec 6, 2025\n\n\nSantiago Burgos-Fallon & Abraham Rock\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/Lab 4/Lab4.html",
    "href": "labs/Lab 4/Lab4.html",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "",
    "text": "In this lab I used an STM32L432KC MCU to play music by toggling a GPIO at precise, timer-controlled rates and feeding the signal into an LM386 amplifier that drives an 8 Ω speaker. The score (Für Elise) is provided as a list of {frequency_Hz, duration_ms} pairs. A frequency of 0 is a rest, and a duration of 0 ends the song.\nI implemented everything without CMSIS: only #define memory-mapped register macros and small helper functions.\n\n\n\nBuild a circuit to let an MCU I/O pin drive a speaker (via LM386).\nImplement timer functionality by reading the datasheet and writing a tiny device driver from scratch.\nGenerate accurate pitches independent of note frequency and respect the specified durations."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#introduction",
    "href": "labs/Lab 4/Lab4.html#introduction",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "",
    "text": "In this lab I used an STM32L432KC MCU to play music by toggling a GPIO at precise, timer-controlled rates and feeding the signal into an LM386 amplifier that drives an 8 Ω speaker. The score (Für Elise) is provided as a list of {frequency_Hz, duration_ms} pairs. A frequency of 0 is a rest, and a duration of 0 ends the song.\nI implemented everything without CMSIS: only #define memory-mapped register macros and small helper functions.\n\n\n\nBuild a circuit to let an MCU I/O pin drive a speaker (via LM386).\nImplement timer functionality by reading the datasheet and writing a tiny device driver from scratch.\nGenerate accurate pitches independent of note frequency and respect the specified durations."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#system-overview",
    "href": "labs/Lab 4/Lab4.html#system-overview",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "System Overview",
    "text": "System Overview\n\nTimer plan: prescale TIM2 to a 1 MHz tick (1 µs per timer count). For a note of frequency ( f ), set the timer auto-reload to the half-period in µs and toggle the GPIO on every update event → 50% duty square wave by construction.\nDuration plan: compute how many half-periods fit in the requested milliseconds and toggle exactly that many times.\nRests: keep the output low and wait for ms timer updates at 1 kHz (ARR = 999 at a 1 MHz tick).\n\nPins used (hardware build): Audio out PA11 (GPIO to LM386 IN+ via pot/divider), START = PB4 (active-low to GND, internal pull-up), RESET = PA6 (active-low to GND, internal pull-up)."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#hardware",
    "href": "labs/Lab 4/Lab4.html#hardware",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Hardware",
    "text": "Hardware\n\nLM386 minimum-parts hookup\n\nInput network:\n\n10 kΩ potentiometer (recommended): MCU pin → pot top; pot bottom → GND; wiper → LM386 pin 3 (IN+) (volume).\n\nLM386 pins:\n\nPin 3 (IN+): from pot wiper or divider node.\n\nPin 2 (IN−) and Pin 4: GND.\n\nPin 5 (OUT): → 220–250 µF electrolytic (+ toward LM386) → speaker +; speaker − → GND; add 0.047–0.05 µF from pin 5 → GND (stability).\n\nPin 6 (V_S): +5…9 V with 0.1 µF (and 10 µF) decoupling to GND near the IC.\n\nPins 1 & 8: open (gain ≈ 20).\n\n\n\nCommon ground: MCU GND, LM386 GND, and speaker − must be tied together."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#timing-accuracy-detailed-calculations-1-µs-timer-tick-tim2-32-bit",
    "href": "labs/Lab 4/Lab4.html#timing-accuracy-detailed-calculations-1-µs-timer-tick-tim2-32-bit",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Timing & Accuracy — Detailed Calculations (1 µs Timer Tick, TIM2 32-bit)",
    "text": "Timing & Accuracy — Detailed Calculations (1 µs Timer Tick, TIM2 32-bit)\nAssumptions:\nTIM2 prescaled to 1 MHz (1 µs per count), upcount to ARR, toggle GPIO on each update (so each update = one half-period). Frequencies are produced by rounding the half-period; durations are produced by counting half-periods. TIM2 on STM32L432 is 32-bit.\n\nCore Formulae\nHalf-period in microseconds for target frequency ( f ) (Hz): \\[\nT_{1/2} \\;=\\; \\frac{1}{2f}\\ \\text{s} \\;=\\; \\frac{500{,}000}{f}\\ \\text{µs}\n\\]\nProgram auto-reload as: \\[\nARR \\;=\\; \\operatorname{round}(T_{1/2}) \\;-\\; 1\n\\]\nActual frequency (because timer quantizes in 1 µs steps): \\[\nf_{\\text{actual}} \\;=\\; \\frac{1}{2\\,\\bigl(ARR+1\\bigr)\\cdot1\\ \\text{µs}}\n\\;=\\;\n\\frac{500{,}000}{ARR+1}\\ \\text{Hz}\n\\]\nPer-half-period rounding is at most ±0.5 µs. Over the full period (two half-periods), the relative pitch error is bounded by: \\[\n\\left|\\frac{\\Delta f}{f}\\right| \\;\\lesssim\\; \\frac{f}{10^{6}}\n\\quad\\text{(with 1 µs tick)}\n\\]\nAt 1 kHz → ≤ 0.10 %; at 220 Hz → ≤ 0.022 % (≪ 1 %).\n\n\n\nTheoretical Frequency Limits (Timer-Only)\nUsing 1 µs tick and a 32-bit auto-reload:\n\nMinimum frequency largest half-period, \\((ARR_{max}= 2^{32}-1)\\): \\[\nT_{1/2,\\max}=(ARR_{\\max}+1)\\cdot1\\,\\text{µs}=4{,}294{,}967{,}296\\ \\text{µs}\n=4{,}294.967296\\ \\text{s}\n\\] Full period 8,589.934592 s. \\[\n\\boxed{f_{\\min}=\\frac{1}{8{,}589.934592}\\ \\text{Hz}=\\mathbf{0.0001164153\\ Hz}}\n\\] (period ≈ 2 h 23 m 10 s)\nMaximum frequency (smallest half-period, (ARR=0)): \\[\nT_{1/2,\\min}=1\\,\\text{µs}\\;\\Rightarrow\\;T=2\\,\\text{µs},\\qquad\n\\boxed{f_{\\max}=\\mathbf{500{,}000\\ Hz}}\n\\]\n\n\n\n\nRepresentative Notes — Actual Values (from round-to-µs)\n\n\n\n\n\n\n\n\n\n\nTarget (f) (Hz)\n(T_{1/2}) ideal (µs) → rounded\n(ARR)\n(f_{}) (Hz)\nError\n\n\n\n\n220.0\n2272.727… → 2273\n2272\n219.9736\n−0.012 %\n\n\n329.6\n1516.989… → 1517\n1516\n329.5979\n−0.00064 %\n\n\n440.0\n1136.364… → 1136\n1135\n440.1408\n+0.032 %\n\n\n523.3\n955.467… → 955\n954\n523.5602\n+0.050 %\n\n\n659.3\n758.380… → 758\n757\n659.6306\n+0.050 %\n\n\n1000.0\n500.000… → 500\n499\n1000.0000\n+0.000 %\n\n\n\n\nFrequency step size near a given (f) from a 1 µs half-period grid is approximately\n(f ). Examples: at 1 kHz → ~2 Hz/step; at 220 Hz → ~0.097 Hz/step.\n\n\n\nDuration Quantization (Notes): What it is, why it happens, and how big the error is\nModel. Each note is played by executing an integer number of half-periods (one GPIO toggle per timer update).\nLet the target frequency be (f) (Hz) and the requested duration be (d) (ms).\n\nHalf-period (with a 1 µs timer tick): \\[\nT_{1/2} \\;=\\; \\frac{1}{2f}\\ \\text{s} \\;=\\; \\frac{500{,}000}{f}\\ \\mu\\text{s}\n\\]\nIdeal (real-valued) number of toggles: \\[\nN^* \\;=\\; \\frac{2 f d}{1000}\n\\]\nImplemented toggles (what code uses): (N=(N^*)) (nearest integer).\nActual time played: \\[\nt_{\\text{actual}} \\;=\\; N\\cdot T_{1/2}\n\\]\n\nWhy quantization error occurs. Because (N) must be an integer, (N) can differ from \\((N^*)\\) by at most \\((T_{1/2})\\). Multiplying by \\((T_{1/2})\\) gives the worst-case time error: \\[\n\\boxed{\\,|\\Delta t_{\\text{note}}| \\;\\le\\; \\tfrac{1}{2}\\,T_{1/2}\\,}\n\\]\nInterpretation. - The step size of note duration is exactly \\[(T_{1/2})\\] (each additional toggle adds one half-period). - The largest absolute error happens at low frequencies \\[(large (T_{1/2}))\\], because the duration “grid” is coarser. - For a given requested duration (d) (e.g., 125 ms), the percent error bound is \\[\n  \\boxed{\\,\\%\\text{error} \\;\\le\\; \\frac{T_{1/2}}{2\\,d}\\times 100\\%\\,}\n  \\]\n\n\nExplicit values\n\n( f = 220, ):\n\\[\nT_{1/2} = \\frac{500{,}000}{220} = 2272.727\\,\\mu\\text{s} = \\mathbf{2.273\\,\\text{ms}}\n\\] \\[\n|\\Delta t| \\le \\tfrac{1}{2}T_{1/2} = \\mathbf{1.136\\,\\text{ms}}\n\\] \\[\n\\%\\text{error} \\le \\frac{2.273}{2\\cdot 125}\\times 100\\% = \\mathbf{0.91\\%}\n\\]\n( f = 440, ):\n\\[\nT_{1/2} = \\frac{500{,}000}{440} = 1136.364\\,\\mu\\text{s} = \\mathbf{1.136\\,\\text{ms}}\n\\] \\[\n|\\Delta t| \\le \\mathbf{0.568\\,\\text{ms}}\n\\] \\[\n\\%\\text{error} \\le \\frac{1.136}{2\\cdot 125}\\times 100\\% = \\mathbf{0.45\\%}\n\\]\n( f = 659.3, ):\n\\[\nT_{1/2} = \\frac{500{,}000}{659.3} = 758.380\\,\\mu\\text{s} = \\mathbf{0.758\\,\\text{ms}}\n\\] \\[\n|\\Delta t| \\le \\mathbf{0.379\\,\\text{ms}}\n\\] \\[\n\\%\\text{error} \\le \\frac{0.758}{2\\cdot 125}\\times 100\\% = \\mathbf{0.30\\%}\n\\]\n( f = 1000, ):\n\\[\nT_{1/2} = \\frac{500{,}000}{1000} = 500.000\\,\\mu\\text{s} = \\mathbf{0.500\\,\\text{ms}}\n\\] \\[\n|\\Delta t| \\le \\mathbf{0.250\\,\\text{ms}}\n\\] \\[\n\\%\\text{error} \\le \\frac{0.500}{2\\cdot 125}\\times 100\\% = \\mathbf{0.20\\%}\n\\]\n\n\nRests: handled by a 1 kHz “ms timer” → granularity 1 ms. Since your rest durations are already integers in ms, the rest error is 0 ms (within that 1 ms quantum).\n\n\n\n\n\nSoftware-Polled Limitations (Practical Upper Bound)\nI implement notes by polling TIM2’s update flag (UIF), then clearing UIF and toggling the GPIO. The timer can generate very fast updates, but to avoid missed toggles the CPU must service each update before the next half-period elapses.\nLet\n\n\\(f_{cpu}\\) = core clock (e.g., 80 MHz)\n\n\\(t_{service}\\) = time for me to (1) detect UIF=1 and exit the loop, (2) clear TIM2_SR, and (3) toggle the ODR bit (plus loop overhead)\n\nTo guarantee no misses I need the half-period to exceed my service time:\n\\[\nT_{1/2} \\;&gt;\\; t_{\\text{service}}\n\\quad\\Longrightarrow\\quad\nf_{\\max,\\text{service}} \\;\\approx\\; \\frac{1}{2\\,t_{\\text{service}}}\n\\]\n\nConcrete examples\n\\[t_{\\text{service}} = 2.0,\\mu\\text{s}\\] \\[\n  f_{\\max,\\text{service}} \\approx \\frac{1}{2\\cdot 2.0\\,\\mu\\text{s}} = \\mathbf{250\\,\\text{kHz}}\n  \\] \\[t_{\\text{service}} = 1.0,\\mu\\text{s}\\] \\[\n  f_{\\max,\\text{service}} \\approx \\frac{1}{2\\cdot 1.0\\,\\mu\\text{s}} = \\mathbf{500\\,\\text{kHz}}\n  \\] \\[t_{\\text{service}} = 0.5,\\mu\\text{s}\\] \\[\n  f_{\\max,\\text{service}} \\approx \\frac{1}{2\\cdot 0.5\\,\\mu\\text{s}} = \\mathbf{1.0\\,\\text{MHz}}\n  \\]\nHowever, with my 1 µs timer tick, the timer itself caps the maximum frequency at\n\\[\nf_{\\max,\\text{timer}} \\;=\\; \\frac{1}{2\\cdot 1\\,\\mu\\text{s}} \\;=\\; \\mathbf{500\\,\\text{kHz}}\n\\]\nSo the true practical max is\n\\[\nf_{\\max} \\;=\\; \\min\\!\\bigl(f_{\\max,\\text{service}},\\, f_{\\max,\\text{timer}}\\bigr)\n\\]\nIn other words:\n\nIf \\(t_{service}\\) &gt; 1s → software-limited below 500 kHz\n\nIf \\(t_{service}\\) &lt; 1s → timer-limited at 500 kHz\n\nEither way, this is orders of magnitude above audio. My Für Elise range (220–1319 Hz) is tiny compared to even a conservative software-limited few-hundred-kHz ceiling.\n\n\n\n\nCompliance Statement (from these calculations)\n\nPitch accuracy (220–1000 Hz): worst-case rounding ≤ 0.10 % @1 kHz and ≤ 0.022 % @220 Hz → meets ±1 % spec with wide margin.\nDurations: note-length error ≤ ½ (T_{1/2}) (≤ 0.25–1.14 ms across 1 kHz–220 Hz for 125 ms notes); rests at 1 ms resolution → tempo is within ~1 % worst case, typically ≪ 1 %.\nRange: timer math supports (f) from 0.000116 Hz up to 500 kHz; software-service considerations are still far above the audio range used here."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#schematic",
    "href": "labs/Lab 4/Lab4.html#schematic",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\nFigure 1: General Schematic."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#writeup-summary-general-specs",
    "href": "labs/Lab 4/Lab4.html#writeup-summary-general-specs",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Writeup / Summary (General Specs)",
    "text": "Writeup / Summary (General Specs)\n\nMeets requirements? Yes.\n\nTime spent: 6 hours.\n\nAI prototype: attempted; reflection below."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#verification-bring-up",
    "href": "labs/Lab 4/Lab4.html#verification-bring-up",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Verification & Bring-Up",
    "text": "Verification & Bring-Up\n\nFunctional checks\n\nRests (f = 0) produce silence for specified ms.\n\nEnd marker (duration = 0) terminates playback cleanly.\n\nSTART (PB4) gates initial playback; RESET (PA6) aborts mid-note.\n\nDebugging approach\n\nAdded debug watches for computed ( ARR ), half-period, and toggle counts.\n\nUsed run + hit-count breakpoints (not single-step), since stepping halts the timer and audio.\n\nLED telemetry for “in-note vs rest” helps confirm tempo without a scope."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#ai-prototype-reflection",
    "href": "labs/Lab 4/Lab4.html#ai-prototype-reflection",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "AI Prototype & Reflection",
    "text": "AI Prototype & Reflection\n\nPrompt used\n\nNoteLLM Prompt\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220 Hz to 1 kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\n\n\nReflection\n\nQuality & speed: The LLM quickly identified a general-purpose timer (TIM2/TIM3), the key equations \\[\nf = \\frac{f_{\\text{TIM}}}{(PSC+1)(ARR+1)},\\qquad ARR \\approx \\frac{f_{\\text{TIM}}}{f(PSC+1)}-1\n\\] and discussed PWM vs. toggle-on-update. It was faster than manual document search when I couldn’t recall register names.\nWith datasheet attached: Accuracy improved—calling out that TIM2 is 32-bit on L4 and lives on APB1 helped bound ranges and justify a 1 MHz tick.\nCompared to my approach: I chose toggle-on-update to guarantee 50% duty without CCR/PWM setup (simpler for an LM386 square-wave input).\n\nLLM as doc search: Helpful for where to look and order of operations (RCC → GPIO → TIM), while I still verified addresses/bitfields in the reference manual.\nTips that worked: Specify the target tick (e.g., “make TIM2 1 MHz”), request the exact init sequence, and state pin constraints so it doesn’t assume PWM unless I want it."
  },
  {
    "objectID": "labs/Lab 4/Lab4.html#conclusions",
    "href": "labs/Lab 4/Lab4.html#conclusions",
    "title": "Lab 4: Digital Audio — Für Elise on STM32L432KC",
    "section": "Conclusions",
    "text": "Conclusions\nThe design satisfies the lab requirements:\n\nPlays Für Elise at the specified tempo with accurate pitches and rests.\nUses bare-metal register macros; no CMSIS.\nTiming math demonstrates ≤ 0.1% typical pitch error (≪ 1%) in 220–1000 Hz.\nThe LM386 stage is correctly biased and decoupled; the MCU never drives the speaker directly.\n\nTime spent: 6 hours.\nFuture work: add a second composition; experiment with PWM+CCR for variable duty or an RC-filtered DAC for softer timbre."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html",
    "href": "labs/Lab 2/Lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab I implemented time-multiplexing to drive a dual common‑anode seven‑segment display using a single hex→segments decoder module. Two 4‑bit nibbles (from DIP switches) are alternately presented to the decoder; high‑side PNP transistors enable exactly one digit at a time. I also displayed the 5‑bit sum of the two hexadecimal inputs on five LEDs and verified safe currents per the iCE40‑UP5K datasheet (§4.17). Designs were simulated in QuestaSim and synthesized in Lattice Radiant."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#introduction",
    "href": "labs/Lab 2/Lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab I implemented time-multiplexing to drive a dual common‑anode seven‑segment display using a single hex→segments decoder module. Two 4‑bit nibbles (from DIP switches) are alternately presented to the decoder; high‑side PNP transistors enable exactly one digit at a time. I also displayed the 5‑bit sum of the two hexadecimal inputs on five LEDs and verified safe currents per the iCE40‑UP5K datasheet (§4.17). Designs were simulated in QuestaSim and synthesized in Lattice Radiant."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#design-testing-methodology",
    "href": "labs/Lab 2/Lab2.html#design-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design & Testing Methodology",
    "text": "Design & Testing Methodology\n\nArchitecture\n\n\n\n\n\n\nFigure 1: Block diagram of the top-level (top).\n\n\n\n\nClocking. The internal HF oscillator (HSOSC) runs at 6 MHz (CLKHF_DIV=2'b11).\n\nMultiplexer/Scan. Dmux divides the 6 MHz clock to a scan clock DivClk, selects which nibble feeds the decoder, and asserts the corresponding digit enable (En1, En2).\n\nDecoder. SevenSeg is a combinational hex→segments decoder with active‑LOW outputs for a common‑anode display (Seg[6:0], where Seg[0]=A … Seg[6]=G).\n\nTop‑level. top wires the pieces together and computes the 5‑bit sum on Sum[4:0] (LEDs are active‑LOW on our board, so the sum is inverted).\n\n\n\nMultiplex timing\nWith HSOSC at 6 MHz and terminal count N, Dmux toggles DivClk every N cycles; the scan frequency is:\n\\[\nf_{\\text{scan}}=\\frac{f_{\\text{clk}}}{2N}.\n\\]\nIn my current code \\(N=60{,}000\\), so\n\\[\nf_{\\text{scan}}=\\frac{6\\,\\mathrm{MHz}}{2\\cdot 60{,}000}\\approx \\mathbf{50\\ \\mathrm{Hz}}.\n\\]\n\n\nHDL overview (key excerpts)\n\ntop.sv\n\nHSOSC at 6 MHz, instantiates Dmux and SevenSeg, drives Sum = ~(Sw1 + Sw2).\n\nDmux.sv\n\nSegInput = (DivClk) ? Sw1 : Sw2;\n\nEn1 = ~DivClk; En2 = DivClk;\n\nCounter toggles DivClk at the chosen scan rate.\n\nSevenSeg.sv\n\n16‑entry case producing active‑LOW segment patterns for 0x0–0xF (e.g., 4'b1001 /*9*/ → Seg=7'b0001100).\n\n\n\n\nUnit tests (simulation)\n\nSevenSeg_tb.sv (self‑checking): sweeps all 16 hex values and compares Seg to expected patterns.\n\ntop_tb.sv: iterates Sw1, Sw2 over 0x00–0xFF and checks Sum == ~(Sw1 + Sw2) and basic enable/segment sanity during scanning.\n\nDmux_tb.sv: spot‑checks scan duty and selection timing.\n\n\n\n\n\n\n\n\n\nFigure 2: SevenSeg waves across 0x0–0xF.\n\n\n\n\n\n\n\n\n\n\nFigure 3: SevenSeg transcript (1 expected X-case mismatch at vec 0).\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: top waves across 0x00–0xFF.\n\n\n\n\n\n\n\n\n\n\nFigure 5: top transcript (all pass)."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#electrical-design-red-led-current-calculations",
    "href": "labs/Lab 2/Lab2.html#electrical-design-red-led-current-calculations",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Electrical Design: red LED current calculations",
    "text": "Electrical Design: red LED current calculations\nThis display is common‑anode. Each segment has its own resistor and is sunk by an FPGA pin when ON (segment output = 0). The anode of the active digit is driven high via a PNP (2N3906). \n\nSegment resistor (per segment, \\(\\mathbf{R} = 240\\,\\Omega\\); common-anode, FPGA sinks)\nWith a PNP digit switch, the active digit’s anode is approximately \\(3.3 - V_{\\mathrm{CE,sat}}\\). The cathode path includes the LED and the FPGA’s \\(V_{\\mathrm{OL}}\\).\n\\[\nV_{\\mathrm{R}} = (3.3 - V_{\\mathrm{CE,sat}}) - V_{\\mathrm{F}} - V_{\\mathrm{OL}}, \\qquad\nI_{\\mathrm{seg}} = \\frac{V_{\\mathrm{R}}}{R_{\\mathrm{seg}}}.\n\\]\nUse conservative bounds \\(V_{\\mathrm{CE,sat}} \\approx 0.25\\,\\mathrm{V}\\) (2N3906) and Table 4.13 limits for \\(V_{\\mathrm{OL}}\\).\nTypical case (\\(V_{\\mathrm{F}} \\approx 1.8\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.2\\,\\mathrm{V}\\)): \\[\nV_{\\mathrm{R}} = 3.3 - 0.25 - 1.8 - 0.2 = 1.05\\,\\mathrm{V}, \\qquad\nI_{\\mathrm{seg}} = \\frac{1.05}{240} \\approx 4.38\\,\\mathrm{mA}.\n\\]\nConservative case (\\(V_{\\mathrm{F}} \\approx 2.0\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.4\\,\\mathrm{V}\\)): \\[\nV_{\\mathrm{R}} = 3.3 - 0.25 - 2.0 - 0.4 = 0.65\\,\\mathrm{V}, \\qquad\nI_{\\mathrm{seg}} = \\frac{0.65}{240} \\approx 2.71\\,\\mathrm{mA}.\n\\]\nBecause the display is multiplexed at ≈50 % duty, the average segment current is \\[I_{\\mathrm{seg,avg}} \\approx 0.5 \\cdot I_{\\mathrm{seg}}\\] ≈2.19 mA typical, ≈1.35 mA conservative.\n\n\n\nSolid stand-alone red LEDs (\\(\\mathbf{R} = 1\\,\\mathrm{k\\Omega}\\), FPGA sinks, no PNP)\nHere the resistor sees \\(V_{\\mathrm{R}} = 3.3 - V_{\\mathrm{F}} - V_{\\mathrm{OL}}\\).\nTypical (\\(V_{\\mathrm{F}} \\approx 1.8\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.2\\,\\mathrm{V}\\)): \\[I = \\frac{3.3 - 1.8 - 0.2}{1000} = \\frac{1.3}{1000} \\approx 1.30\\,\\mathrm{mA}.\\]\nConservative (\\(V_{\\mathrm{OL}} \\approx 0.4\\,\\mathrm{V}\\)): \\[I = \\frac{3.3 - 1.8 - 0.4}{1000} = \\frac{1.1}{1000} \\approx 1.10\\,\\mathrm{mA}.\\]\n\n\n\nPNP anode driver (per digit, \\(\\mathbf{R}_{\\mathrm{B}} = 1\\,\\mathrm{k\\Omega}\\))\nWorst-case segment load when displaying “8”: \\[I_{\\mathrm{C}} \\approx 7 \\cdot I_{\\mathrm{seg}}.\\]\nBase-resistor drop when ON: \\[V_{\\mathrm{RB}} \\approx V_{\\mathrm{E}} - V_{\\mathrm{BE,sat}} - V_{\\mathrm{OL}}.\\]\nWith \\(V_{\\mathrm{BE,sat}} \\approx 0.65\\text{–}0.85\\,\\mathrm{V}\\) and \\(V_{\\mathrm{OL}} \\approx 0.2\\text{–}0.4\\,\\mathrm{V}\\), \\[V_{\\mathrm{RB}} \\approx 3.3 - (0.65\\text{–}0.85) - (0.2\\text{–}0.4) \\approx 2.45\\text{–}2.05\\,\\mathrm{V}.\\]\nFor \\(R_{\\mathrm{B}} = 1\\,\\mathrm{k\\Omega}\\), \\[I_{\\mathrm{B}} \\approx \\frac{V_{\\mathrm{RB}}}{R_{\\mathrm{B}}} \\approx 2.05\\text{–}2.45\\,\\mathrm{mA}.\\]\nForced-beta check \\(\\beta_{\\mathrm{forced}} = I_{\\mathrm{C}} / I_{\\mathrm{B}}\\):\n\nTypical brightness (\\(I_{\\mathrm{seg}} \\approx 4.38\\,\\mathrm{mA}\\)):   \\(I_{\\mathrm{C}} \\approx 30.6\\,\\mathrm{mA}\\),   \\(\\beta_{\\mathrm{forced}} \\approx 12.5\\text{–}15\\).\nConservative brightness (\\(I_{\\mathrm{seg}} \\approx 2.71\\,\\mathrm{mA}\\)):   \\(I_{\\mathrm{C}} \\approx 19.0\\,\\mathrm{mA}\\),   \\(\\beta_{\\mathrm{forced}} \\approx 7.8\\text{–}9.3\\).\n\nThese values are suitable for saturating a 2N3906 in this current range."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#technical-documentation",
    "href": "labs/Lab 2/Lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nCode directory (this lab):\n\ntop.sv — top level (HSOSC @ 6 MHz, Dmux, SevenSeg, Sum LEDs)\nDmux.sv — divider + input select + digit enables\nSevenSeg.sv — hex→7‑segment decoder (active‑LOW)\n*_tb.sv — basic testbenches (SevenSeg_tb.sv, Dmux_tb.sv, top_tb.sv)\n\nTools: Radiant (synthesis, constraints, Netlist Analyzer), QuestaSim Lattice Edition (simulation).\n\n\nNotes that matter for this lab\n\nActive‑LOW segments. Common‑anode means driving a 0 turns a segment ON. Keep all case patterns consistent with this polarity.\nOne decoder only. Both digits share the same decoder → time‑multiplex inputs and enables.\nBrightness uniformity. Identical per‑segment resistors and a fixed 50% duty for each digit keep perceived brightness similar across numbers.\nScan rate. If you observe flicker or “ghosting,” increase \\(f_{\\text{scan}}\\) (reduce N)."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#results-discussion",
    "href": "labs/Lab 2/Lab2.html#results-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results & Discussion",
    "text": "Results & Discussion\n\nThe decoder produced the correct segment patterns for 0x0–0xF in simulation and on the physical board. The summing LED’s also followed the expected behavior.\n\nAt (N=60,000) (≈50 Hz scan), both digits are readable, with no visible flicker present.\nThe 5‑bit Sum LEDs matched Sw1 + Sw2 for all 256 input pairs in the top‑level test."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#conclusion",
    "href": "labs/Lab 2/Lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nI met the Lab 2 requirements: a single seven‑segment decoder time‑multiplexed across two digits, the sum on five LEDs, and current‑safe driving using PNP anode switches with per‑segment resistors. The design is modular (Dmux, SevenSeg, top) and synthesizes cleanly.\nTime spent: (8) hours."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#ai-implementation",
    "href": "labs/Lab 2/Lab2.html#ai-implementation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Implementation",
    "text": "AI Implementation\n\nPrompt used\n\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\n\n\nWhat the LLM produced\n\nGood ideas it used\n\nKept one hex→7-segment decoder and time-multiplexed the inputs (correct per spec).\nAdded a parameterized scan divider with $clog2 sizing and a clean always_ff counter.\nSplit the design into clear modules: a scan/mux block (selects nibble + digit enables) and the existing decoder.\nUsed always_comb for pure combinational logic and documented active-LOW segment polarity (common-anode).\nSuggested a sim mode with a tiny divider under ifndef SYNTHESIS to speed testbenches.\n\nGaps I had to fix\n\nThe first draft instantiated the decoder twice (one per digit). I rewired to feed a single decoder with the selected nibble.\nDigit enable polarity was backward for a PNP high-side scheme; I inverted the enables so only one anode is ON at a time.\n\n\n\n\nQuality rating (and why)\n\nRating: B+\nWhy: Architecture and modularity were solid, scan logic was close to correct, and it respected the “single decoder” objective after edits. Minor polarity mistakes and a comment/math mismatch kept it from an A.\n\n\n\nDid it synthesize first time?\n\nNot exactly. With the provided oscillator and decoder, it built after two small fixes:\n\nRemoved the duplicate decoder instance and fed the single instance from the scan mux.\n\nFlipped digit-enable polarity to match the common-anode via PNP wiring.\n\n\n\n\nWhat I’d do differently next time with an LLM\n\nPin down polarity & wiring in the prompt: “common-anode, active-LOW segments, PNP digit enables, single decoder” to avoid the duplicate-decoder and enable-polarity missteps.\n\nSpecify the exact primitives up front: “use the provided HSOSC and SegDisp modules by name” to prevent library/primitive swaps."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html",
    "href": "labs/Lab 7/Lab7.html",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "",
    "text": "In this lab I implemented a 128-bit AES encryption accelerator in SystemVerilog and wrapped it with a simple SPI shift interface so an MCU can send a key and plaintext and read back the ciphertext. The AES core is an iterative, multi-cycle design (1 round per few cycles) sized to the FPGA’s resources. I verified function first in simulation (core TB, then SPI TB), then used a logic analyzer to confirm timing and bit ordering on the hardware link.\nLearning outcomes: specification-driven design, datapath + controller partitioning, MCU↔︎FPGA interface timing, structured debug with simulation + LA, and a taste of hardware acceleration."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#introduction",
    "href": "labs/Lab 7/Lab7.html#introduction",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "",
    "text": "In this lab I implemented a 128-bit AES encryption accelerator in SystemVerilog and wrapped it with a simple SPI shift interface so an MCU can send a key and plaintext and read back the ciphertext. The AES core is an iterative, multi-cycle design (1 round per few cycles) sized to the FPGA’s resources. I verified function first in simulation (core TB, then SPI TB), then used a logic analyzer to confirm timing and bit ordering on the hardware link.\nLearning outcomes: specification-driven design, datapath + controller partitioning, MCU↔︎FPGA interface timing, structured debug with simulation + LA, and a taste of hardware acceleration."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#system-overview",
    "href": "labs/Lab 7/Lab7.html#system-overview",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "System Overview",
    "text": "System Overview\nTop-level flow. MCU →(SPI: 256 SCK in)→ FPGA (aes_spi) → aes_core → ciphertext latched →(SPI: 128 SCK out)→ MCU, which compares against a known test vector.\nAES mode. AES-128, Nr = 10 rounds (Nk = 4, Nb = 4). The round sequence is:\n\nInitial AddRoundKey\nRounds 1–9: SubBytes → ShiftRows → MixColumns → AddRoundKey\nRound 10: SubBytes → ShiftRows → AddRoundKey (no MixColumns)\n\n\n\n\n\n\n\nFigure 1: block diagram Schematic.\n\n\n\n\nSPI Interface (FPGA side)\n\nMode CPOL=0/CPHA=0: sample sdi on posedge SCK; update sdo on negedge SCK.\nShift-in phase (256 edges): {plaintext, key} MSB-first.\nCompute phase: load deasserted; core runs ~11 fabric clocks and raises done.\nShift-out phase (128 edges): cipher MSB-first; the first MSB is driven as soon as done rises (before next SCK edge), then sdo updates on negedges."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#design-approach",
    "href": "labs/Lab 7/Lab7.html#design-approach",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "Design Approach",
    "text": "Design Approach\n\nDatapath\n\nState register (128b) holds the current AES state.\nRoundKey register (128b) holds the active round key.\nSubBytes: 16× sbox_sync (1-cycle, uses BRAM; sbox.txt ROM init).\nShiftRows: hard-wired byte permutes.\nMixColumns: 4× column units with GF(2^8) multiply-by-x helper (galoismult with poly 0x1B).\nAddRoundKey: 4× 32-bit XORs.\n\n\n\nController (FSM)\nStates (conceptually):\n\nIDLE — wait for load; stage plaintext/key for initial ARK.\nINIT_ARK — compute state = plaintext ^ key.\nROUND_PREP — present state to SubBytes; keyexp sees {round, rk}.\nSUB_ISSUE / SUB_CAPTURE — burn 1 cycle for sbox_sync, latch SubBytes.\nSR_STAGE — apply ShiftRows.\nMC_STAGE — apply MixColumns (skip when round==10).\nARK_STAGE / ARK_FINAL — XOR with next round key; increment round; on final, latch cyphertext and assert done.\nFINISH — hold done high until next load.\n\n\n\nKey Expansion (AES-128)\n\nImplements RotWord → SubWord → XOR with Rcon on the last word, then chained XORs to form the next 128-bit round key.\nRcon sequence uses {0x01, 0x02, 0x04, …, 0x1B, 0x36} for rounds 1..10.\nSubWord uses the same sbox_sync (1-cycle)."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#implementation-notes",
    "href": "labs/Lab 7/Lab7.html#implementation-notes",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "Implementation Notes",
    "text": "Implementation Notes\n\nThe iterative core fits comfortably; the S-box is the dominant area (maps to BRAM/LUT RAM depending on tool inference).\nBecause sbox_sync is synchronous, I inserted an explicit one-cycle gap between presenting bytes and capturing the substituted result.\nThe final round bypasses MixColumns via a small mux on the ARK input.\nThe SPI module double-buffers the outbound ciphertext so sdo is valid immediately on done and then continues shifting on SCK negedges."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#test-plan",
    "href": "labs/Lab 7/Lab7.html#test-plan",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "Test Plan",
    "text": "Test Plan\n\nFunctional Vectors (Core TB)\n\nNIST AES-128 example (Appendix A/B):\n\nkey = 2b7e151628aed2a6abf7158809cf4f3c\nplaintext = 3243f6a8885a308d313198a2e0370734\nExpected ciphertext = 3925841d02dc09fbdc118597196a0b32\n\nThe core TB drives load, clocks through 10 rounds, and checks done and the final value.\n\n\n\n\n\n\n\nFigure 2: core wave forms.\n\n\n\n\n\nEnd-to-End SPI (SPI TB)\n\nShifts {plaintext, key} MSB-first on sdi with 256 posedges.\nDeasserts load and waits for done.\nSamples sdo on posedge SCK while I update it on negedge (128 cycles).\nCompares the assembled 128-bit value with the golden.\nOn success, the TB prints “Testbench ran successfully” and calls $stop to allow wave inspection.\n\n\n\n\n\n\n\n\n\nFigure 3: Spi waves.\n\n\n\n\n\n\n\n\n\n\nFigure 4: Spi transcript."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#mcu-fpga-interface",
    "href": "labs/Lab 7/Lab7.html#mcu-fpga-interface",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "MCU ↔︎ FPGA Interface",
    "text": "MCU ↔︎ FPGA Interface\n\nThe provided lab7.c drives the SPI transaction and compares the ciphertext locally. No changes needed as long as:\n\nCPOL/CPHA = 0/0 (match FPGA).\nNSS/CE held active during each continuous shift window.\nBit order MSB-first.\n\nOn success, the MCU prints a pass banner and can toggle a status LED."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#results",
    "href": "labs/Lab 7/Lab7.html#results",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "Results",
    "text": "Results\n\nCore TB: passes the NIST vector.\nSPI TB: passes end-to-end; ciphertext matches."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#time-spent",
    "href": "labs/Lab 7/Lab7.html#time-spent",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "Time Spent",
    "text": "Time Spent\n~20 hours ."
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#known-limitations-future-work",
    "href": "labs/Lab 7/Lab7.html#known-limitations-future-work",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "Known Limitations / Future Work",
    "text": "Known Limitations / Future Work\n\nCurrent core is encrypt-only; no decryption path.\nOne round per several cycles; could pipeline rounds for higher throughput (at area cost).\nAdd AXI-lite or memory-mapped interface for queued requests.\nParameterize for AES-192/256 key sizes.\n\nSchematic standards: labeled pins/parts/values, junction dots, left-to-right flow, neat layout, title block. HDL standards: one module/file, descriptive names, comments, clear hierarchy, individual module TBs, include TB outputs in report.\n\n\n\n\n\n\nFigure 5: general schematic"
  },
  {
    "objectID": "labs/Lab 7/Lab7.html#ai-prototype",
    "href": "labs/Lab 7/Lab7.html#ai-prototype",
    "title": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nPrototype A — With Spec (FIPS-197 available)\nPrompt. “Write SystemVerilog HDL to implement the KeyExpansion logic described in the FIPS-197 uploaded document. The module should be purely combinational, using the previous key and current round number to calculate the next key. Assume other required modules (SubWord and RotWord) are already implemented.”\nOutcome (what happened). The LLM produced a clean combinational keyexpansion with:\n\nCorrect Rcon mapping for rounds 1..10.\nRotWord then SubWord on w3, XOR chain w0'..w3'.\nProper port widths and MSB-first word ordering.\n\nAnalysis. It synthesized immediately. Because my in-lab design uses synchronous SubWord (via sbox_sync), I swapped the prototype’s pure-comb SubWord call for my existing registered version and inserted one holding cycle in the controller. The generated structure matched FIPS-197, so functional results were identical.\n\n\nPrototype B — Without Spec (No “AES” Mention)\nPrompt. (Rephrased, no “AES” terms; uses the provided abstract pseudocode with module1, module2, Rcon and loop unrolling instructions.)\nOutcome (what happened). The LLM generated a module that:\n\nPreserved the word-wise recurrence and XOR chain.\nExposed a param for Nk and Nr, but mis-handled Rcon for i/Nk ≥ 9 (missed 0x1B→0x36 step).\nTreated module1/module2 as black-box instances correctly, but defaulted them to combinational timing.\n\nAnalysis. Functionally close but not spec-exact (Rcon corner), which is expected without domain context. After I fixed the Rcon table and aligned timing to my synchronous SubWord, it matched Prototype A. Takeaway: LLMs can mirror control/data recurrences from pseudocode well, but spec-driven constants (like Rcon sequences) still need expert review."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html",
    "href": "labs/Lab 1/Lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab I assembled the E155 development board, verified power rails, and brought up both the UPduino v3.1 FPGA (iCE40-UP5K) and the Nucleo-L432KC MCU. I then wrote SystemVerilog to (1) drive three LEDs per the given truth tables and (2) decode a 4-bit input from the on-board DIP switches (SW6) to a common-anode 7-segment display. The switches provide s[3:0] directly into the FPGA; the decoder drives seg[6:0] (active-low) through 1k ohm resistors to the display so that the selected hex digit lights correctly. Designs were simulated in QuestaSim, synthesized in Lattice Radiant, and programmed to the UP5K;"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#introduction",
    "href": "labs/Lab 1/Lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab I assembled the E155 development board, verified power rails, and brought up both the UPduino v3.1 FPGA (iCE40-UP5K) and the Nucleo-L432KC MCU. I then wrote SystemVerilog to (1) drive three LEDs per the given truth tables and (2) decode a 4-bit input from the on-board DIP switches (SW6) to a common-anode 7-segment display. The switches provide s[3:0] directly into the FPGA; the decoder drives seg[6:0] (active-low) through 1k ohm resistors to the display so that the selected hex digit lights correctly. Designs were simulated in QuestaSim, synthesized in Lattice Radiant, and programmed to the UP5K;"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#design-testing-methodology",
    "href": "labs/Lab 1/Lab1.html#design-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design & Testing Methodology",
    "text": "Design & Testing Methodology\n\nArchitecture\n\nInternal 48 MHz HSOSC feeds a power-on reset counter and a parameterized divider that creates a ~2.4 Hz tick for led[2].\nled_logic implements the required LED truth tables and optional active-low polarity.\nSevenSeg is a combinational hex→segments decoder with active-low outputs (for a common-anode display).\n\n\n\n\n\n\n\nFigure 1: Block diagram of the top-level (sbf_lab1).\n\n\n\n\n\nUnit tests (simulation)\nSelf-checking testbenches read .tv vectors: - tb_SevenSeg_tv verifies the 0x0–0xF map. - tb_led_logic_tv checks both active-high and active-low instances. - tb_lab1_sbf_tv checks seg and led[1:0] at top level (blink bit ignored).\n\nOn the single “error”: one vector intentionally contains unknowns (xxxxxxx) to represent a “don’t-care” state during initialization. The testbench expects xxxxxxx, while real hardware (with pull-ups and reset) resolves to 1111111 (all segments off). Functionally correct; the failure is in the expected vector, not the DUT.\n\n\n\nHardware bring-up\n\nVerified +5 V and +3.3 V LDO outputs on VIN power before inserting modules.\nWired one side of the dual 7-segment (common-anode) with series resistors on each segment; anode to 3.3 V.\nUsed ~1 kΩ series resistors → ≈3.3 mA/segment (ignoring LED (V_f)), comfortably within limits: [ I = 3.3  ]\n\n\n\n\n\n\n\nFigure 2: Hand-drawn schematic and current note (common-anode with ~1 kΩ resistors)."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#technical-documentation",
    "href": "labs/Lab 1/Lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nCode directory: https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201\n\nFPGA design: `sbf_lab1 (top).\nTestbenches: tb_all.sv.\n\nTools: Radiant (synthesis, constraints, Netlist Analyzer), QuestaSim Lattice Edition (simulation), SEGGER Embedded Studio (MCU).\n\n\nLED behavior specification\n\n\n\nS1\nS0\nled[0]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nON\n\n\n1\n0\nON\n\n\n1\n1\nOFF\n\n\n\n\n\n\nS3\nS2\nled[1]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nOFF\n\n\n1\n0\nOFF\n\n\n1\n1\nON\n\n\n\nled[2] blinks at ~2.4 Hz from the divider: \\[\n\\mathrm{TOGGLE\\_COUNT}\n= \\frac{48\\,\\mathrm{MHz}}{2 \\cdot 2.4\\,\\mathrm{Hz}} - 1\n= 10{,}000{,}000 - 1\n\\]\n\n\nSeven-segment notes\n\nCommon-anode display → active-low segment lines (0 turns a segment on).\nNaming: seg[0]=A … seg[6]=G.\nTo turn on correct segments:"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#results-discussion",
    "href": "labs/Lab 1/Lab1.html#results-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results & Discussion",
    "text": "Results & Discussion\n\nSeven-segment unit tests\n\n\n\n\n\n\n\n\nFigure 3: SevenSeg waves across 0x0–0xF.\n\n\n\n\n\n\n\n\n\n\nFigure 4: SevenSeg transcript (1 expected X-case mismatch at vec 0).\n\n\n\n\n\n\n\nLED logic unit tests\n\n\n\n\n\n\n\n\nFigure 5: LED logic waves (active-high and active-low instances).\n\n\n\n\n\n\n\n\n\n\nFigure 6: LED logic transcript (all pass).\n\n\n\n\n\n\n\nTop-level simulation\n\n\n\n\n\n\n\n\nFigure 7: Top-level (sbf_lab1) QuestaSim waves sweeping s=0..F.\n\n\n\n\n\n\n\n\n\n\nFigure 8: Top-level transcript (1 error corresponds to X-expectation init vector).\n\n\n\n\n\nInterpretation.\n- led_logic passes all vectors for both polarities.\n- SevenSeg and top-level each show one flagged vector where the testbench expects unknowns; hardware resolves to all off (1111111). Functionality is correct; the discrepancy is only in the expected file’s init case.\n- Divider math and POR behavior match intent; led[2] toggles at the expected rate (simulation time scaled)."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#conclusion",
    "href": "labs/Lab 1/Lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nI assembled and powered the E155 dev board, verified MCU↔︎FPGA connectivity, and implemented the required FPGA logic: LED truth tables, a ~2.4 Hz blink, and a combinational 7-segment decoder for a common-anode display. Simulation, synthesis, and on-board testing confirm correct behavior. The lone “failure” in automated tests is a deliberate X-expectation vector that resolves to “all off” in hardware.\nTime spent: 20 hours."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#all-code-httpsgithub.coms4anti4goe155treemainfpgaradiantprojectlab201",
    "href": "labs/Lab 1/Lab1.html#all-code-httpsgithub.coms4anti4goe155treemainfpgaradiantprojectlab201",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "All Code https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201",
    "text": "All Code https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#ai-implementation",
    "href": "labs/Lab 1/Lab1.html#ai-implementation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Implementation",
    "text": "AI Implementation\n\nPrompt\n\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nWhat the LLM produced (Gemini)\nGood ideas it used: - Parameterized divider (CLK_FREQ, BLINK_FREQ) with $clog2 sizing - Modern SV constructs (logic, always_ff) - Clear split: top module that wraps an oscillator primitive + a blinker child\nTop-level snippet returned (abridged): module led_blink_top (output logic o_led); logic clk_48mhz; SB_HFOSC u_hfosc ( .CLKHFPU(1’b1), .CLKHFEN(1’b1), .CLKHF(clk_48mhz) ); defparam u_hfosc.CLKHF_DIV = “0b00”; // 48 MHz led_blinker u_led_blinker (.clk(clk_48mhz), .led(o_led)); endmodule\n\n\nSynthesis outcome\nRadiant failed at the oscillator instantiation with: VERI-1063: instantiating unknown module SB_HFOSC Root cause: Radiant’s iCE40 UltraPlus technology library expects the HSOSC primitive, not SB_HFOSC (the SB_* form is common in iCEcube2 examples).\nFix applied (works in Radiant): // iCE40UP internal HF oscillator HSOSC #(.CLKHF_DIV(2’b00)) // 00 = 48 MHz hf_osc (.CLKHFPU(1’b1), .CLKHFEN(1’b1), .CLKHF(clk));\nI also replaced the LLM’s initial-based register inits with a tiny synchronous power-on reset (POR) counter so hardware powers up in a known state.\n\n\nQuality rating (and why)\n\nRating: B\n\nStrengths: idiomatic SV, readable, correct divide-by-N math, parameterized for reuse\n\nWeak spots: vendor primitive mismatch (SB_HFOSC vs HSOSC), defparam string style (\"0b00\"), reliance on initial for synthesis reset\n\n\n\nWhat I learned / new constructs\n\n$clog2 is handy for auto-sizing counters and synthesizes cleanly on UP5K.\nParameterizing the blink frequency made switching between 2 Hz (prompt) and 2.4 Hz (lab) a one-line change.\n\n\n\nErrors & warnings encountered\n\nRadiant: VERI-1063 instantiating unknown module SB_HFOSC → resolved by switching to HSOSC #(.CLKHF_DIV(2'b00)) and wiring CLKHFPU/CLKHFEN/CLKHF.\n\n\n\nTips for using LLMs for HDL (next-time playbook)\n\nSpecify tool, family, and exact primitive in the prompt: target Lattice Radiant for iCE40 UltraPlus (UP5K) and instantiate HSOSC (ports CLKHFPU, CLKHFEN, CLKHF; param CLKHF_DIV).\nAsk for a synthesizable reset: avoid initial; include a synchronous reset or a small POR counter.\nRequest a sim-friendly testbench: faster divider + self-check to validate logic quickly.\nAsk for Radiant-specific guidance: prefer Device Constraint Editor notes over generic .lpf.\nIterate with exact error text: paste Radiant/Questa messages back to the LLM for precise fixes.\n\n\n\nAppendix: Figure index\n\nBlock diagram: hmc-e155-portfolio/labs/Lab1/images/sv.jpg\n\nSchematic & current calc: hmc-e155-portfolio/labs/Lab1/images/elec.jpg\n\nTop-level waves: hmc-e155-portfolio/labs/Lab1/images/lab test waves.png, hmc-e155-portfolio/labs/Lab1/images/lab vectors.png\n\nLED unit waves: hmc-e155-portfolio/labs/Lab1/images/led test waves.png, hmc-e155-portfolio/labs/Lab1/images/led text tests.png\n\nSeven-seg waves: hmc-e155-portfolio/labs/Lab1/images/seven seg waves.png, hmc-e155-portfolio/labs/Lab1/images/seven seg tests.png"
  },
  {
    "objectID": "labs/Lab 6/Lab6.html",
    "href": "labs/Lab 6/Lab6.html",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "",
    "text": "In this lab I built a small IoT device: an STM32L432KC microcontroller talks SPI to a DS1722 digital thermometer and UART to an ESP8266 that serves a minimal HTML page. The webpage lets a user toggle an LED, view the temperature, and select the sensor resolution (8–12 bits). I wrote a CMSIS-only SPI driver, verified the serial links with a logic analyzer, and debugged the DS1722 configuration so higher-resolution modes update correctly."
  },
  {
    "objectID": "labs/Lab 6/Lab6.html#introduction",
    "href": "labs/Lab 6/Lab6.html#introduction",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "",
    "text": "In this lab I built a small IoT device: an STM32L432KC microcontroller talks SPI to a DS1722 digital thermometer and UART to an ESP8266 that serves a minimal HTML page. The webpage lets a user toggle an LED, view the temperature, and select the sensor resolution (8–12 bits). I wrote a CMSIS-only SPI driver, verified the serial links with a logic analyzer, and debugged the DS1722 configuration so higher-resolution modes update correctly."
  },
  {
    "objectID": "labs/Lab 6/Lab6.html#system-overview",
    "href": "labs/Lab 6/Lab6.html#system-overview",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "System Overview",
    "text": "System Overview\nData path. DS1722 →(SPI)→ MCU →(UART)→ ESP8266 →(Wi-Fi AP)→ browser. Control path. Browser requests /ledon, /ledoff, or /res{8..12} → ESP forwards /REQ:... to MCU → MCU toggles LED and/or updates DS1722 configuration → MCU renders fresh HTML → ESP serves it.\nGeneral Schematic. \n\nDS1722 Essentials (what finally made it work)\n\nConfig register layout: I map R2:R1:R0 to bits 3:2:1 and keep SD=0 for continuous conversions.\nI/O addresses: read 0x00, write 0x80.\nData format: left-justified 12-bit signed; 1 LSB = 1/256 °C:\nExpected CONFIG hex (sanity checks): 8-bit → 0xE0, 9-bit → 0xE2, 10-bit → 0xE4, 11-bit → 0xE6, 12-bit → 0xE8.\nConversion time increases with resolution (≈75 ms @8-bit up to ≈1.2 s @12-bit). The registers hold the last completed value until the new conversion finishes; that’s why higher resolutions appear “slower.”\n\n\n\nSPI Driver (CMSIS)\n\nInitializes SPI1 with chosen prescaler, CPHA=1, software-managed NSS.\nManual CE is asserted HIGH before sending the address and stays high through the data byte(s).\nBlocking 8-bit transfers via DR with TXE/RXNE polling.\n\n\n\nESP8266 Request Protocol\n\nESP sends a single line like:\n/REQ:ledon\\n\n/REQ:          (for root /)\n/REQ:res12\nMCU parses the token, updates LED or DS1722 config, then returns a complete HTML page. The ESP forwards it to the browser once it sees &lt;/html&gt; (or after a 200 ms idle gap)."
  },
  {
    "objectID": "labs/Lab 6/Lab6.html#web-page-ui",
    "href": "labs/Lab 6/Lab6.html#web-page-ui",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "Web Page / UI",
    "text": "Web Page / UI\n\nControls: LED On/Off buttons; resolution buttons (8/9/10/11/12-bit).\nTelemetry: current temperature in °C and °F; current CONFIG byte (for debug).\nMinimal CSS for legibility.\n\n\nHTML Generation Notes\n\nThe MCU emits the HTTP header and then a single HTML document (no AJAX).\nEach button click triggers a fresh page render (stateless).\nOn a resolution change, the page reads CONFIG back and displays it so I can confirm the write took effect."
  },
  {
    "objectID": "labs/Lab 6/Lab6.html#logic-analyzer-capture",
    "href": "labs/Lab 6/Lab6.html#logic-analyzer-capture",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "Logic Analyzer Capture",
    "text": "Logic Analyzer Capture\n\n\n\n\n\n\nFigure 1: Logic Trace.\n\n\n\nWhat to see:\n\nCONFIG write: CE goes HIGH, MOSI sends 0x80 (write), then the data byte (e.g., 0xE8 for 12-bit). SCK edges align with CPHA=1.\nTemperature read: CE HIGH, MOSI 0x01 (LSB addr) then one dummy byte; MISO shows LSB. Repeat for MSB (0x02).\nIdles return MISO high"
  },
  {
    "objectID": "labs/Lab 6/Lab6.html#results",
    "href": "labs/Lab 6/Lab6.html#results",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "Results",
    "text": "Results\n\nLED control from the webpage works reliably.\nTemperature displays in °C and °F, updates on each refresh.\nResolution switching 8→12 bits works; CONFIG shows the expected hex.\nAt higher resolutions the value updates more slowly (by design); the last reading is held until the new conversion completes—consistent with the datasheet."
  },
  {
    "objectID": "labs/Lab 6/Lab6.html#time-spent",
    "href": "labs/Lab 6/Lab6.html#time-spent",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "Time Spent",
    "text": "Time Spent\n~14 hours"
  },
  {
    "objectID": "labs/Lab 6/Lab6.html#known-limitations-future-work",
    "href": "labs/Lab 6/Lab6.html#known-limitations-future-work",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "Known Limitations / Future Work",
    "text": "Known Limitations / Future Work\n\nNo auto-refresh; a timed meta-refresh or small JS would update values without clicks.\nCould add an on-page indicator for “conversion in progress” at higher resolutions.\nBurst read (MSB+LSB under one CE) would reduce overhead slightly."
  },
  {
    "objectID": "labs/Lab 6/Lab6.html#ai-prototype",
    "href": "labs/Lab 6/Lab6.html#ai-prototype",
    "title": "Lab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)",
    "section": "AI Prototype",
    "text": "AI Prototype\nPrompt 1 (UI):\n\nI’m making a web portal to interface with a temperature sensor. Create an HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\n\nWhat happened. The LLM produced a clean, semantic HTML/CSS snippet with buttons for LED on/off and resolution (8–12). It assumed typical REST paths (/ledon, /res12) which matched the lab’s /REQ:... pass-through, so I only had to paste the &lt;body&gt; into my MCU string generation. Styling was lightweight and rendered fine on mobile. Takeaway: For front-end scaffolding, the LLM sped things up and required minimal edits.\nPrompt 2 (SPI function):\n\nWrite me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\n\nWhat happened. The first draft mixed HAL calls and got CPHA wrong, and it didn’t keep CE asserted across address+data. It also read only one byte (dropping either MSB or LSB). After I corrected to CMSIS-only, enforced CPHA=1, kept CE high, and read both bytes, the code worked. The LLM was useful as a skeleton, but device-specific details (register map, timing, bit fields) needed careful verification against the datasheet and on the logic analyzer.\nOverall: LLMs handled UI boilerplate very well. For low-level peripheral code, they were helpful to outline structure, but hardware-exact details still required my domain knowledge and lab instrumentation to validate and fix."
  },
  {
    "objectID": "labs/Lab 5/Lab5.html",
    "href": "labs/Lab 5/Lab5.html",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "",
    "text": "In this lab, I configured an STM32L432KC to read a quadrature encoder on a brushed DC motor and compute angular velocity in rev/s and direction. The system updates the user at a rate of ≥ 1 Hz via ITM/SWO printf (no UART). The design uses external interrupts (EXTI) on both rising and falling edges of both quadrature channels (x4 decoding) to ensure it does not miss pulses at normal or high speeds. It also correctly reports a velocity of zero when the motor is stopped.\n\n\n\nImplement an interrupt-driven quadrature decoder that converts A/B transitions to signed ticks.\nConvert ticks to rev/s with a clean \\(\\Delta\\text{ticks}/\\Delta t\\) estimator and a 1 Hz output rate.\nUnderstand Gray-code transitions and why using x4 edge detection increases resolution.\nCompare interrupts vs. polling for high-speed signal processing and analyze the conditions for missing pulses."
  },
  {
    "objectID": "labs/Lab 5/Lab5.html#introduction",
    "href": "labs/Lab 5/Lab5.html#introduction",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "",
    "text": "In this lab, I configured an STM32L432KC to read a quadrature encoder on a brushed DC motor and compute angular velocity in rev/s and direction. The system updates the user at a rate of ≥ 1 Hz via ITM/SWO printf (no UART). The design uses external interrupts (EXTI) on both rising and falling edges of both quadrature channels (x4 decoding) to ensure it does not miss pulses at normal or high speeds. It also correctly reports a velocity of zero when the motor is stopped.\n\n\n\nImplement an interrupt-driven quadrature decoder that converts A/B transitions to signed ticks.\nConvert ticks to rev/s with a clean \\(\\Delta\\text{ticks}/\\Delta t\\) estimator and a 1 Hz output rate.\nUnderstand Gray-code transitions and why using x4 edge detection increases resolution.\nCompare interrupts vs. polling for high-speed signal processing and analyze the conditions for missing pulses."
  },
  {
    "objectID": "labs/Lab 5/Lab5.html#system-overview",
    "href": "labs/Lab 5/Lab5.html#system-overview",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "System Overview",
    "text": "System Overview\n\nMCU: STM32L432KC (Cortex-M4F @ 80 MHz)\nEncoder resolution: \\(PPR_{\\times1} = 408 \\rightarrow CPR_{\\times4} = 1632\\) counts per revolution\nPins (5 V tolerant):\n\nA → PA6 (EXTI6, handled by EXTI9_5_IRQHandler)\nB → PB4 (EXTI4, handled by EXTI4_IRQHandler)\n\nInterrupt config: Trigger on rising and falling edges for both channels A and B to achieve x4 decoding.\nTime base: SysTick running at 1 kHz for a precise \\(\\Delta t\\) and 1 Hz reporting schedule.\nLogging: ITM/SWO printf (with float print support enabled) and unbuffered output for reliability.\n\n\nVelocity Math\nFor a reporting window of duration \\(\\Delta t\\) (in seconds), the firmware computes the velocity as follows:\n\\[\\Delta\\text{ticks} = \\text{tick\\_count}(t_2) - \\text{tick\\_count}(t_1)\\]\n\\[\\text{revolutions} = \\frac{\\Delta\\text{ticks}}{\\text{CPR}_{\\times4}}\\]\n\\[\\text{rev/s} = \\frac{\\text{revolutions}}{\\Delta t}\\]\nDirection is determined by the sign of \\(\\Delta\\text{ticks}\\): FWD if \\((&gt;0)\\), REV if \\((&lt;0)\\), and STILL if \\((=0)\\) or no edges have been detected in the last 0.5 seconds."
  },
  {
    "objectID": "labs/Lab 5/Lab5.html#hardware",
    "href": "labs/Lab 5/Lab5.html#hardware",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "Hardware",
    "text": "Hardware\n\nSchematic\n\n\n\n\n\n\nFigure 1: General Schematic."
  },
  {
    "objectID": "labs/Lab 5/Lab5.html#flowchart",
    "href": "labs/Lab 5/Lab5.html#flowchart",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "Flowchart",
    "text": "Flowchart\n\n\n\n\n\n\nFigure 2: Code Flow."
  },
  {
    "objectID": "labs/Lab 5/Lab5.html#verification-calculations",
    "href": "labs/Lab 5/Lab5.html#verification-calculations",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "Verification & Calculations",
    "text": "Verification & Calculations\n\nExpected Counts at ~10 rev/s\nWith the motor’s true resolution of \\(CPR_{\\times4} = 1632\\), we can predict the number of ticks generated per second at an angular velocity of \\(\\omega = 10\\ \\text{rev/s}\\):\n\\[\\Delta\\text{ticks}_{1s} \\approx 10\\ \\text{rev/s} \\cdot 1632\\ \\text{ticks/rev} = \\boxed{16320\\ \\text{ticks/s}}\\]\nA representative console output over a 1-second window would look like this:\nvel=10.00490 rev/s  dir=FWD  (dticks=16328)\nCheck: We can verify this measurement by plugging the tick count back into our formula: \\[\\text{rps} = \\frac{16328 \\text{ ticks}}{1632 \\text{ ticks/rev}} \\div 1.000\\ \\text{s} = 10.0049\\ \\text{rev/s}\\] This result perfectly matches the calculated velocity, confirming the system’s accuracy.\n\n\nDirection Check\n\nFWD rotation produces the Gray-code sequence 00→01→11→10→00, which the ISR’s lookup table correctly scores as +1 per edge.\nREV rotation traverses the cycle in the opposite order, resulting in a score of −1 per edge.\nThe console output correctly toggles between dir=FWD and dir=REV when the motor shaft is reversed by hand.\n\n\n\nZero-Velocity Check\nIf no valid encoder edges are detected for 0.5 seconds, the main loop forces rps=0.0 and dir=STILL. This was verified by stopping the motor; the status line correctly updated to zero within the next print cycle."
  },
  {
    "objectID": "labs/Lab 5/Lab5.html#interrupts-vs.-polling",
    "href": "labs/Lab 5/Lab5.html#interrupts-vs.-polling",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "Interrupts vs. Polling",
    "text": "Interrupts vs. Polling\nFor high-frequency signal processing like reading a quadrature encoder, an interrupt-driven approach is overwhelmingly superior to polling. Interrupts provide efficiency, reliability, and real-time responsiveness that polling cannot match.\nAn easy analogy is checking your mailbox.\n\nPolling is like walking out to the curb every 5 minutes to see if the mail has arrived. It’s repetitive, wastes your time, and you might miss the mail truck if you happen to be busy inside when it drives by.\nInterrupts are like having a doorbell. You can do other things, and the mail carrier rings the bell the moment the mail is delivered. You respond immediately and efficiently, without wasting any effort.\n\n\nWhy Interrupts Are Better\n\n\n\n\n\n\n\n\nFeature\nPolling\nInterrupt-Driven\n\n\n\n\nCPU Usage\nVery High. The CPU is stuck in a tight loop, constantly checking GPIO states. This consumes 100% of its processing cycles, even when the motor is stopped.\nVery Low. The CPU can perform other tasks or enter a low-power sleep mode. It only consumes cycles when an actual edge event occurs.\n\n\nResponsiveness\nPoor & Unpredictable. Latency depends on the polling loop’s execution time (\\(t_{\\text{loop}}\\)). If the loop contains other tasks, the response to an edge can be significantly delayed.\nExcellent & Deterministic. The hardware detects the edge and vectors to the ISR within a few clock cycles. The latency is minimal and highly predictable.\n\n\nReliability\nLow. Polling is prone to missing events. If the time between edges (\\(T_{\\text{edge}}\\)) is less than the loop time (\\(T_{\\text{edge}} &lt; t_{\\text{loop}}\\)), the system will fail to count edges, leading to incorrect velocity and position data.\nHigh. The EXTI hardware latches events. As long as the ISR is short enough to execute before the next edge arrives, no events will be missed. This makes the system robust even at very high speeds.\n\n\nSystem Design\nComplex & Brittle. Integrating other tasks with a polling loop is difficult and often leads to tangled, hard-to-maintain code. It forces a compromise between responsiveness and functionality.\nClean & Scalable. Promotes an event-driven architecture where time-critical tasks (ISRs) are cleanly separated from less critical ones (main loop). This is more modular and easier to build upon.\n\n\n\n\n\nThe Polling Failure Point\nA polling-based system fails when the CPU cannot check the input pins fast enough to catch every state change. For our motor with \\(CPR_{\\times4} = 1632\\) spinning at \\(\\omega = 10\\ \\text{rev/s}\\), the time between consecutive edges becomes extremely short:\n\\[T_{\\text{edge}} = \\frac{1}{\\text{edges/s}} = \\frac{1}{\\omega \\cdot \\text{CPR}_{\\times4}} = \\frac{1}{10 \\cdot 1632} = \\frac{1}{16320} \\approx 61.3\\ \\mu\\text{s}\\]\nIf the polling loop takes longer than 61.3 microseconds to complete—a very likely scenario if the CPU is doing anything else—it will inevitably start missing encoder ticks. Our interrupt-based design, with a hardware-triggered, constant-time ISR, is far faster and therefore never missed pulses during testing at any speed.\nFrom an oscilloscope trace, I ran polling without any other tasks, to see how fast I could get it to poll. It showed a maximum speed of 88 us as seen in the trace below. This fails to meet the above outlined criteria.\n\n\n\n\n\n\nFigure 3: Poll Trace"
  },
  {
    "objectID": "labs/Lab 5/Lab5.html#time-spent",
    "href": "labs/Lab 5/Lab5.html#time-spent",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "Time Spent",
    "text": "Time Spent\n8 hours."
  },
  {
    "objectID": "labs/Lab 5/Lab5.html#ai-prototype-reflection",
    "href": "labs/Lab 5/Lab5.html#ai-prototype-reflection",
    "title": "Lab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC",
    "section": "AI Prototype & Reflection",
    "text": "AI Prototype & Reflection\nPrompt used (example): “Write EXTI interrupt handlers for a quadrature encoder on an STM32L432KC. Which 5 V-tolerant pins can map cleanly to EXTI, and how do I implement x4 decoding using a lookup table in the ISR?”\nExperience:\n\nThe LLM rapidly produced a working skeleton for the EXTI configuration, handlers, and suitable pin choices.\nI refined the initial code to use pins PA6/PB4, corrected the EXTICR register configuration, and implemented a more robust printing mechanism via ITM _write (matching the class-provided snippet).\nThe LLM was most helpful as a sounding board for establishing the correct peripheral initialization order (RCC → GPIO → SYSCFG/EXTI → NVIC) and for explaining the logic behind a lookup-table decoder.\nThe biggest “gotcha” it didn’t initially catch was that float printf support must be explicitly enabled in the project settings; otherwise, SWO prints appear as gibberish. Once this was enabled, the output was clean.\n\nTakeaways for using an LLM effectively:\n\nBe specific: State the exact MCU, pins, and peripheral constraints (e.g., “5 V-tolerant only”, “A=PA6, B=PB4”).\nBe explicit: Ask for specific features like “both rising and falling edges” and “x4 decoding”.\nIterate: Request a minimal working version first, then build upon it for reliability (e.g., add a zero-velocity rule, use unbuffered stdout)."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html",
    "href": "labs/Lab 3/Lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab I designed and verified a 4×4 matrix keypad scanner on an iCE40 FPGA. The design registers each key exactly once (on press), filters bounce, ignores additional keys while one is held, and displays the last two hex digits on a dual common-anode seven-segment display (most recent on the right). The keypad orientation is aligned with the display.\n\nDisplay polarity. Common-anode → Seg[6:0] are active-LOW and digit enables select which anode is active."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#introduction",
    "href": "labs/Lab 3/Lab3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "In this lab I designed and verified a 4×4 matrix keypad scanner on an iCE40 FPGA. The design registers each key exactly once (on press), filters bounce, ignores additional keys while one is held, and displays the last two hex digits on a dual common-anode seven-segment display (most recent on the right). The keypad orientation is aligned with the display.\n\nDisplay polarity. Common-anode → Seg[6:0] are active-LOW and digit enables select which anode is active."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#system-overview",
    "href": "labs/Lab 3/Lab3.html#system-overview",
    "title": "Lab 3: Keypad Scanner",
    "section": "System Overview",
    "text": "System Overview\n\nBlock Diagram\n\n\n\n\n\n\nFigure 1: Block diagram.\n\n\n\n\n\nTop-Level Architecture\n\nClocking: Lattice HSOSC at ~6 MHz (CLKHF_DIV=2'b11).\nKeypad interface:\n\nRows (Row[3:0]) are FPGA outputs, one row driven LOW at a time (scan).\nColumns (Col[3:0]) are FPGA inputs with pull-ups (PULLMODE=UP). A pressed key shorts the active low row to its column → that column reads 0.\n\nScanner (KeypadScan):\n\nRound-robin row scan (≈2 kHz), 2-FF synchronizers on Col[3:0].\nFSM with states IDLE → DEB → HELD.\n\nOn first detection, freeze the candidate row/col and debounce for a few scan ticks.\nEmit a 1-cycle key_valid on acceptance, then ignore other keys until all columns return high.\n\n\nDisplay path: On key_valid, shift {D_left, D_right} ← {D_right, key_code}. A single SevenSeg instance decodes the selected nibble; DMux alternates enables (En1, En2) and feeds the decoder input (s) at a fixed duty to avoid brightness variation.\n\n\n\n\n\n\n\nFigure 2: RTL"
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#state-machine-specification",
    "href": "labs/Lab 3/Lab3.html#state-machine-specification",
    "title": "Lab 3: Keypad Scanner",
    "section": "State Machine Specification",
    "text": "State Machine Specification\n\nState Diagram\n\n\n\n\n\n\nFigure 3: FSM"
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#state-transition-table",
    "href": "labs/Lab 3/Lab3.html#state-transition-table",
    "title": "Lab 3: Keypad Scanner",
    "section": "State Transition Table",
    "text": "State Transition Table\n\nIDLE – transitions\n\n\n\n\n\n\n\n\n\nCurrent State\nCondition (plain English)\nNext State\nNotes\n\n\n\n\nIDLE\nA key seems pressed (while scanning, some column reads LOW)\nDEB\nLatch the candidate key = (active row, first LOW column); compute hex\n\n\nIDLE\nOtherwise\nIDLE\nContinue round-robin row scan\n\n\n\n\n\nDEB – transitions\n\n\n\n\n\n\n\n\n\nCurrent State\nCondition (plain English)\nNext State\nNotes\n\n\n\n\nDEB\nAll columns are HIGH again (looks like release or a glitch)\nIDLE\nAbort debounce; resume scanning\n\n\nDEB\nOn the scan strobe, the same candidate column is still LOW and the stable count just reached the target (e.g., 3 in a row)\nHELD\nAccept the key; emit a one-clock key_valid pulse\n\n\nDEB\nOn the scan strobe, the same candidate column is still LOW but the stable count hasn’t reached the target\nDEB\nKeep counting consecutive stable observations\n\n\nDEB\nOn the scan strobe, the candidate column is not LOW\nDEB\nReset the stable counter to zero\n\n\nDEB\nOtherwise\nDEB\nKeep the candidate row held LOW and wait for next scan strobe\n\n\n\n\n\nHELD – transitions\n\n\n\n\n\n\n\n\n\nCurrent State\nCondition (plain English)\nNext State\nNotes\n\n\n\n\nHELD\nAll columns are HIGH (the key has been fully released)\nIDLE\nReturn to scanning; allow a new key\n\n\nHELD\nOtherwise (key still held, or other keys also pressed)\nHELD\nIgnore additional keys until full release\n\n\n\n\n\nOutputs & Actions (per state)\n\n\n\n\n\n\n\n\n\nState\nRow Drive (what we drive on the keypad)\nRegisters / Counters (what we latch/update)\nOne-Cycle Outputs\n\n\n\n\nIDLE\nRound-robin: one row LOW at a time (…1110 → 1101 → 1011 → 0111…)\nOn first LOW column: latch candidate row & column, compute and hold candidate hex, clear stable counter\nkey_valid = 0\n\n\nDEB\nFreeze: keep only the candidate row LOW\nOn each scan strobe: if same column still LOW → increment stable counter; else reset to 0\nWhen target count reached on a strobe: key_valid = 1 (one clock)\n\n\nHELD\nFreeze: keep only the candidate row LOW\nWait until all columns HIGH (full release); counters unchanged\nkey_valid = 0\n\n\n\n\nMini-glossary (for the table)\n\nScan strobe: periodic tick that advances row scan and paces debouncing.\nCandidate key: first detected (row, column) pair; row is held during debounce.\nStable count: number of consecutive scan strobes where that same column remains LOW (target e.g. 3).\nAll columns HIGH: no key asserted (1111 due to pull-ups).\n\n\n\n\n\nOne-liners for implementation cross-check\n\nAccept press when: state==DEB && scan_tick && stable_cand && deb_cnt==N_stable-1 → key_valid&lt;=1, state&lt;=HELD.\nAbort bounce when: state==DEB && all_released → deb_cnt&lt;=0, state&lt;=IDLE.\nIgnore additional keys while HELD: do nothing until all_released."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#debouncing-metastability",
    "href": "labs/Lab 3/Lab3.html#debouncing-metastability",
    "title": "Lab 3: Keypad Scanner",
    "section": "Debouncing & Metastability",
    "text": "Debouncing & Metastability\n\nSynchronizers: Each Col[x] passes through a two-flip-flop chain (col_s1 → col_sync) clocked at 6 MHz to mitigate metastability.\nDebounce window: Acceptance requires three stable observations of the candidate column under a frozen row. This balances responsiveness and immunity to mechanical bounce.\nSingle-event guarantee: key_valid is generated once, on the press edge only. While in HELD, new presses are ignored until release."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#timing-multiplexing",
    "href": "labs/Lab 3/Lab3.html#timing-multiplexing",
    "title": "Lab 3: Keypad Scanner",
    "section": "Timing & Multiplexing",
    "text": "Timing & Multiplexing\n\nScan Timing\nA 13-bit divider creates a ~2 kHz scan tick. Rows step: 1110 → 1101 → 1011 → 0111. The debounce counter advances only on scan ticks. Timing can be seen on top Module Wave form.\n\n\nDisplay Timing (DMux)\nDMux toggles a digit select at ~50 Hz (counter=60 000 at 6 MHz → 50 Hz).\n\ns = (DivClk) ? D_right : D_left\nEn2 = DivClk, En1 = ~DivClk\nConstant duty keeps brightness uniform, independent of the number of lit segments.\n\nTiming can be seen on top Module Wave form."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#pinout-orientation",
    "href": "labs/Lab 3/Lab3.html#pinout-orientation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Pinout & Orientation",
    "text": "Pinout & Orientation\n\nRows (outputs): connect to keypad R0..R3.\nColumns (inputs w/ pull-up): connect to keypad C0..C3.\nThe map_hex table encodes the keypad legend for (row, col) indices consistent with the chosen orientation.\n\n\n\n\n\n\n\nFigure 4: Layout Schematic"
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#hdl-summary-files-roles",
    "href": "labs/Lab 3/Lab3.html#hdl-summary-files-roles",
    "title": "Lab 3: Keypad Scanner",
    "section": "HDL Summary (files & roles)",
    "text": "HDL Summary (files & roles)\n\ntop.sv — HSOSC, KeypadScan, capture registers for last two digits, DMux, SevenSeg.\nKeypadScan.sv — row scan, 2-FF input sync, IDLE/DEB/HELD FSM, map_hex(r,c).\nDMux.sv — display multiplexer + digit enables (fixed duty).\nSevenSeg.sv — combinational hex→segments (active-LOW).\n\nAll combinational logic is in always_comb; sequential is in always_ff with a single driver per reg (no latches, no tri-states)."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#simulation-verification",
    "href": "labs/Lab 3/Lab3.html#simulation-verification",
    "title": "Lab 3: Keypad Scanner",
    "section": "Simulation & Verification",
    "text": "Simulation & Verification\n\nTestbench Strategy\n\nA behavioral keypad model drives Col[3:0] LOW only when the DUT selects the matching row LOW.\nThe TB issues a sequence of 16 keys (walks the matrix), waits for key_valid, and then checks the two displayed digits by sampling when each enable is active.\nNegative tests:\n\nHold one key, “press” another → verify the second is ignored until release.\nInject brief bounces on a column line → ensure single registration.\n\n\n\n\n\n\n\n\n\n\nFigure 5: Keypad Scan, Dmux, and Top waveforms.\n\n\n\n\n\n\n\n\n\n\nFigure 6: waveform transcript (1 expected X-case mismatch at vec 0).\n\n\n\n\n\n\n\nResults (simulation)\n\nEach programmed key press produced one key_valid pulse and the expected key_code.\nWith one key held, additional simulated presses did not register.\nDisplay sampling showed stable, non-flickering output; both digits had equal duty."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#hardware-bring-up-measurements",
    "href": "labs/Lab 3/Lab3.html#hardware-bring-up-measurements",
    "title": "Lab 3: Keypad Scanner",
    "section": "Hardware Bring-Up & Measurements",
    "text": "Hardware Bring-Up & Measurements\n\nVerified with a multimeter that each button shorts exactly one Row to one Col (&lt;100 Ω) and that Col idles at 1111 with no key (internal pull-ups).\nConfirmed row order and column order match the map_hex orientation by observing a temporary LED debug (~Row, ~Col) and adjusting constraints where needed.\nFinal board test: pressing any key updates the right digit; the previous right digit shifts to the left. Press-and-hold does not cause repeats; additional presses are ignored until release."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#design-tradeoffs-alternatives",
    "href": "labs/Lab 3/Lab3.html#design-tradeoffs-alternatives",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design Tradeoffs & Alternatives",
    "text": "Design Tradeoffs & Alternatives\n\nDebounce length: I chose 3 scan-ticks (≈1.5 ms at ~2 kHz) for a good balance of responsiveness vs. bounce immunity. Longer windows reduce false triggers but feel less snappy.\nScan rate: ~2 kHz row stepping comfortably exceeds bounce dynamics and avoids aliasing; slower scanning risks missing very short taps.\nSingle decoder + mux: Minimizes area and guarantees identical glyphs; the tradeoff is a need for careful duty control to keep brightness uniform.\nFirst-press policy vs. NKRO: For a diode-less matrix, “first-press wins” avoids ghosting; true multi-key (NKRO) would require per-switch diodes or a more complex detection + ghost-masking strategy.\nSynchronizers: 2-FF is sufficient at 6 MHz; 3-FF would further reduce MTBF at the cost of extra latency."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#schematic-notes",
    "href": "labs/Lab 3/Lab3.html#schematic-notes",
    "title": "Lab 3: Keypad Scanner",
    "section": "Schematic Notes",
    "text": "Schematic Notes\n\nColumns: inputs with PULLMODE=UP\nRows: push-pull outputs; one driven LOW at a time.\nDisplay: common-anode; segment resistors per segment; enables at constant duty."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#conclusions",
    "href": "labs/Lab 3/Lab3.html#conclusions",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusions",
    "text": "Conclusions\nThe implemented keypad scanner meets the lab requirements:\n\nCorrectly reads the 4×4 keypad, debounces, and registers once per press.\nIgnores additional keys while one is held.\nDrives the dual 7-segment display with stable brightness and correct ordering (most-recent on right).\nUses clean, latch-free, tri-state-free RTL with proper synchronizers.\n\nTime spent: (12 hours). Known limitations / future work:\n\nAdd a compile-time option to speed the scan/dividers in simulation.\nAuto-detect row/col orientation at power-up to reduce pin-map bring-up friction."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#appendix",
    "href": "labs/Lab 3/Lab3.html#appendix",
    "title": "Lab 3: Keypad Scanner",
    "section": "Appendix",
    "text": "Appendix\n\nFile List\ntop.sv\nKeypadScan.sv\nDMux.sv\nSevenSeg.sv\nhsosc_sim.sv   // simulation model only\n*_tb.sv        // keypad + display testbenches\n\n\nKey Equations\n\nDisplay scan: \\(f_{\\text{scan}} = \\dfrac{f_{\\text{clk}}}{2N}\\) (N = DMux terminal count).\nDebounce window: \\(T_{\\text{deb}} = N_{\\text{stable}} / f_{\\text{row-scan}}\\)."
  },
  {
    "objectID": "labs/Lab 3/Lab3.html#ai-implementation",
    "href": "labs/Lab 3/Lab3.html#ai-implementation",
    "title": "Lab 3: Keypad Scanner",
    "section": "AI Implementation",
    "text": "AI Implementation\n\nPrompt used\n\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4×4 matrix keypad and display the last two hex keys pressed on a dual 7-segment display. Implement: • A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. • A keypad scanning controller that iterates one active-low column at a time and samples active-low rows, registering at most one key per press (debounce-by-design), ignoring additional presses while any key is held, and allowing a new registration only after release. • A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time-multiplexed two-digit 7-segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices. Create a new Radiant project, type the code generated by the LLM in and analyze the results. If the synthesis fails, type the error message back into the LLM to see what suggestions it generates.\n\n\n\nWhat the LLM produced\n\nGood ideas it used\n\nClear module split: KeypadScan (scanner + debounce FSM), DMux (digit scan/mux), SevenSeg (combinational hex→segments), top (capture two digits, wire-up).\nSynchronous FSM with three states (IDLE → DEB → HELD), a one-shot key_valid pulse on accept, and two-flip-flop synchronizers on the asynchronous column inputs.\nRound-robin row drive and frozen row during debounce, which prevents ghosting and enforces “first press wins.”\nTime-multiplexed display with fixed duty for uniform brightness, and active-LOW segment patterns for a common-anode display.\nIncluded a scan tick to pace debounce (stable-N policy), keeping all counters/sequencing in always_ff and decoding in always_comb.\n\nGaps I had to fix\n\nRow/column polarity & direction: the prompt assumed active-low columns and sampled rows, but our board drives rows (active-LOW) and reads columns (with pull-ups). I corrected the interface and comments to match hardware.\nKey mapping: the default (row,col)→hex map didn’t match the physical keypad legend; I rewrote map_hex to our layout.\nMultiple drivers risk: key_valid was assigned in more than one procedural context in one draft. I consolidated to a single always_ff.\nDebounce edge case: the counter was clocked every system cycle; I tied it to the scan strobe so stability is measured per row sample.\nSimulation speed: initial dividers made sims painfully long; I added small counts under a guarded sim mode while leaving hardware rates intact.\n\n\n\n\nQuality rating (and why)\n\nRating: A-\nWhy: The LLM delivered a solid modular architecture and a correct synchronous FSM with proper input synchronization and single-event registration. Most fixes were integration details (board polarity, key legend, divider sizing) rather than structural rewrites.\n\n\n\nDid it synthesize first time?\n\nAlmost. It compiled after minor edits:\n\nAlign row/column direction and polarity with our board.\nFix a single-writer rule on key_valid.\nAdjust the (row,col)→hex lookup to the actual keypad legend.\nTweak divider constants (fast for sim, slow for hardware) and confirm no latches/tri-states.\n\n\n\n\nWhat I’d do differently next time with an LLM\n\nState the physical contract explicitly in the prompt: “Rows = outputs, active-LOW; Columns = inputs with pull-ups (idle=1111); Segments active-LOW; digit enables En1/En2 select left/right.”\nProvide the keypad legend and pin swap up front and ask the model to generate map_hex from a small (row,col)→label table.\nAsk for +ifdef SIM dividers from the start to keep waveforms short and readable.\nRequire one-process-per-reg and “no $clog2/parameters” if a strict style is desired, so the draft matches house style without edits."
  },
  {
    "objectID": "posts/FirstPost.html",
    "href": "posts/FirstPost.html",
    "title": "First Post!",
    "section": "",
    "text": "I’m excited for MicroPs because I get to see my code affect hardware in the real world. Writing something, probing a pin, and watching the scope confirm it did what I intended is the kind of feedback loop that makes the work satisfying and helps me absorb information.\nThis semester I want to build fluency in the basics that make systems reliable: read reference manuals without getting stuck, set up clocks cleanly, bring up GPIO/timers/serial, and write small drivers with clear init and ISR paths. I want to use interrupts and DMA with intent, understand when HAL or an RTOS helps (and when it doesn’t), and get better at debugging with a logic analyzer and scope instead of guessing.\nBy the end, I’m excited to be able to partake in a focused project I care about that uses the information I learned from the class. Looking forward to it :D"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "Labs",
    "section": "",
    "text": "Lab 7: AES-128 Hardware Accelerator & SPI MCU Link\n\n\nIterative AES core on FPGA with SPI front-end; MCU sends key/plaintext and verifies ciphertext; debug with a logic analyzer\n\n\n\n\n\nOct 30, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6: IoT Web Portal & SPI Temperature Sensor (DS1722)\n\n\nSTM32L432KC CMSIS SPI driver + ESP8266 web portal to read temperature and control an LED at user-selectable resolutions (8–12 bits)\n\n\n\n\n\nOct 27, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5: Interrupts — Quadrature Encoder Velocity on STM32L432KC\n\n\nMeasure motor speed (rev/s) and direction using EXTI interrupts on a quadrature encoder. A=PA6, B=PB4. ITM/SWO printf at ≥1 Hz.\n\n\n\n\n\nOct 9, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4: Digital Audio — Für Elise on STM32L432KC\n\n\nSquare-wave audio synthesis with timer-driven GPIO → LM386 → 8 Ω speaker. No CMSIS; bare-metal register macros.\n\n\n\n\n\nSep 30, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3: Keypad Scanner\n\n\n4×4 matrix keypad scanner with debouncing, single-event registration, and dual 7-segment output\n\n\n\n\n\nSep 17, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\nA time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins\n\n\n\n\n\nSep 11, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1: FPGA and MCU Setup and Testing\n\n\nExplore the microcontroller unit (MCU) and field-programmable gate array (FPGA) development boards used in this course.\n\n\n\n\n\nAug 29, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Resources.html",
    "href": "Resources.html",
    "title": "Resources",
    "section": "",
    "text": "MAN 6400 Data Sheet\n\n\nhttps://hmc-e155.github.io/assets/doc/MAN64x0%20Series.pdf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE155 Course Page\n\n\nWhat the title says\n\n\n\n\n\n\n\n\nNo matching items"
  }
]