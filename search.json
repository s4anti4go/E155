[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "First Post!\n\n\nWhat Im looking forward to in Micro P’s\n\n\n\n\n\nAug 29, 2024\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "Labs",
    "section": "",
    "text": "Lab 7: The Advanced Encryption Standard\n\n\nA hardware accelerator to perform 128-bit AES encryption\n\n\n\n\n\nOct 9, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6: The Internet of Things and Serial Peripheral Interface\n\n\nAn internet-accessible device to control an onboard LED and measure ambient temperature\n\n\n\n\n\nOct 2, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5: Interrupts\n\n\nUse MCU to determine the speed of a motor by reading from a quadrature encoder using interrupts.\n\n\n\n\n\nSep 25, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4: Digital Audio\n\n\nUse MCU to play music by using timers to generate square waves by toggling a GPIO pin at a specific frequency for specified durations\n\n\n\n\n\nSep 18, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\nA time-multiplexing scheme to drive two seven-segment displays with a single set of FPGA I/O pins\n\n\n\n\n\nSep 11, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3: Keypad Scanner\n\n\nDesigned a circuit interface to read a matrix keypad on an FPGA\n\n\n\n\n\nSep 11, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1: FPGA and MCU Setup and Testing\n\n\nExplore the microcontroller unit (MCU) and field-programmable gate array (FPGA) development boards used in this course.\n\n\n\n\n\nAug 29, 2025\n\n\nSantiago Burgos-Fallon\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/Lab 2/Lab2.html",
    "href": "labs/Lab 2/Lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab I implemented time-multiplexing to drive a dual common‑anode seven‑segment display using a single hex→segments decoder module. Two 4‑bit nibbles (from DIP switches) are alternately presented to the decoder; high‑side PNP transistors enable exactly one digit at a time. I also displayed the 5‑bit sum of the two hexadecimal inputs on five LEDs and verified safe currents per the iCE40‑UP5K datasheet (§4.17). Designs were simulated in QuestaSim and synthesized in Lattice Radiant."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#introduction",
    "href": "labs/Lab 2/Lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "In this lab I implemented time-multiplexing to drive a dual common‑anode seven‑segment display using a single hex→segments decoder module. Two 4‑bit nibbles (from DIP switches) are alternately presented to the decoder; high‑side PNP transistors enable exactly one digit at a time. I also displayed the 5‑bit sum of the two hexadecimal inputs on five LEDs and verified safe currents per the iCE40‑UP5K datasheet (§4.17). Designs were simulated in QuestaSim and synthesized in Lattice Radiant."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#design-testing-methodology",
    "href": "labs/Lab 2/Lab2.html#design-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design & Testing Methodology",
    "text": "Design & Testing Methodology\n\nArchitecture\n\n\n\n\n\n\nFigure 1: Block diagram of the top-level (top).\n\n\n\n\nClocking. The internal HF oscillator (HSOSC) runs at 6 MHz (CLKHF_DIV=2'b11).\n\nMultiplexer/Scan. Dmux divides the 6 MHz clock to a scan clock DivClk, selects which nibble feeds the decoder, and asserts the corresponding digit enable (En1, En2).\n\nDecoder. SevenSeg is a combinational hex→segments decoder with active‑LOW outputs for a common‑anode display (Seg[6:0], where Seg[0]=A … Seg[6]=G).\n\nTop‑level. top wires the pieces together and computes the 5‑bit sum on Sum[4:0] (LEDs are active‑LOW on our board, so the sum is inverted).\n\n\n\nMultiplex timing\nWith HSOSC at 6 MHz and terminal count N, Dmux toggles DivClk every N cycles; the scan frequency is:\n\\[\nf_{\\text{scan}}=\\frac{f_{\\text{clk}}}{2N}.\n\\]\nIn my current code \\(N=60{,}000\\), so\n\\[\nf_{\\text{scan}}=\\frac{6\\,\\mathrm{MHz}}{2\\cdot 60{,}000}\\approx \\mathbf{50\\ \\mathrm{Hz}}.\n\\]\n\n\nHDL overview (key excerpts)\n\ntop.sv\n\nHSOSC at 6 MHz, instantiates Dmux and SevenSeg, drives Sum = ~(Sw1 + Sw2).\n\nDmux.sv\n\nSegInput = (DivClk) ? Sw1 : Sw2;\n\nEn1 = ~DivClk; En2 = DivClk;\n\nCounter toggles DivClk at the chosen scan rate.\n\nSevenSeg.sv\n\n16‑entry case producing active‑LOW segment patterns for 0x0–0xF (e.g., 4'b1001 /*9*/ → Seg=7'b0001100).\n\n\n\n\nUnit tests (simulation)\n\nSevenSeg_tb.sv (self‑checking): sweeps all 16 hex values and compares Seg to expected patterns.\n\ntop_tb.sv: iterates Sw1, Sw2 over 0x00–0xFF and checks Sum == ~(Sw1 + Sw2) and basic enable/segment sanity during scanning.\n\nDmux_tb.sv: spot‑checks scan duty and selection timing.\n\n\n\n\n\n\n\n\n\nFigure 2: SevenSeg waves across 0x0–0xF.\n\n\n\n\n\n\n\n\n\n\nFigure 3: SevenSeg transcript (1 expected X-case mismatch at vec 0).\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: top waves across 0x00–0xFF.\n\n\n\n\n\n\n\n\n\n\nFigure 5: top transcript (all pass)."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#electrical-design-red-led-current-calculations",
    "href": "labs/Lab 2/Lab2.html#electrical-design-red-led-current-calculations",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Electrical Design: red LED current calculations",
    "text": "Electrical Design: red LED current calculations\nThis display is common‑anode. Each segment has its own resistor and is sunk by an FPGA pin when ON (segment output = 0). The anode of the active digit is driven high via a PNP (2N3906). \n\nSegment resistor (per segment, \\(\\mathbf{R} = 240\\,\\Omega\\); common-anode, FPGA sinks)\nWith a PNP digit switch, the active digit’s anode is approximately \\(3.3 - V_{\\mathrm{CE,sat}}\\). The cathode path includes the LED and the FPGA’s \\(V_{\\mathrm{OL}}\\).\n\\[\nV_{\\mathrm{R}} = (3.3 - V_{\\mathrm{CE,sat}}) - V_{\\mathrm{F}} - V_{\\mathrm{OL}}, \\qquad\nI_{\\mathrm{seg}} = \\frac{V_{\\mathrm{R}}}{R_{\\mathrm{seg}}}.\n\\]\nUse conservative bounds \\(V_{\\mathrm{CE,sat}} \\approx 0.25\\,\\mathrm{V}\\) (2N3906) and Table 4.13 limits for \\(V_{\\mathrm{OL}}\\).\nTypical case (\\(V_{\\mathrm{F}} \\approx 1.8\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.2\\,\\mathrm{V}\\)): \\[\nV_{\\mathrm{R}} = 3.3 - 0.25 - 1.8 - 0.2 = 1.05\\,\\mathrm{V}, \\qquad\nI_{\\mathrm{seg}} = \\frac{1.05}{240} \\approx 4.38\\,\\mathrm{mA}.\n\\]\nConservative case (\\(V_{\\mathrm{F}} \\approx 2.0\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.4\\,\\mathrm{V}\\)): \\[\nV_{\\mathrm{R}} = 3.3 - 0.25 - 2.0 - 0.4 = 0.65\\,\\mathrm{V}, \\qquad\nI_{\\mathrm{seg}} = \\frac{0.65}{240} \\approx 2.71\\,\\mathrm{mA}.\n\\]\nBecause the display is multiplexed at ≈50 % duty, the average segment current is \\[I_{\\mathrm{seg,avg}} \\approx 0.5 \\cdot I_{\\mathrm{seg}}\\] ≈2.19 mA typical, ≈1.35 mA conservative.\n\n\n\nSolid stand-alone red LEDs (\\(\\mathbf{R} = 1\\,\\mathrm{k\\Omega}\\), FPGA sinks, no PNP)\nHere the resistor sees \\(V_{\\mathrm{R}} = 3.3 - V_{\\mathrm{F}} - V_{\\mathrm{OL}}\\).\nTypical (\\(V_{\\mathrm{F}} \\approx 1.8\\,\\mathrm{V}, V_{\\mathrm{OL}} \\approx 0.2\\,\\mathrm{V}\\)): \\[I = \\frac{3.3 - 1.8 - 0.2}{1000} = \\frac{1.3}{1000} \\approx 1.30\\,\\mathrm{mA}.\\]\nConservative (\\(V_{\\mathrm{OL}} \\approx 0.4\\,\\mathrm{V}\\)): \\[I = \\frac{3.3 - 1.8 - 0.4}{1000} = \\frac{1.1}{1000} \\approx 1.10\\,\\mathrm{mA}.\\]\n\n\n\nPNP anode driver (per digit, \\(\\mathbf{R}_{\\mathrm{B}} = 1\\,\\mathrm{k\\Omega}\\))\nWorst-case segment load when displaying “8”: \\[I_{\\mathrm{C}} \\approx 7 \\cdot I_{\\mathrm{seg}}.\\]\nBase-resistor drop when ON: \\[V_{\\mathrm{RB}} \\approx V_{\\mathrm{E}} - V_{\\mathrm{BE,sat}} - V_{\\mathrm{OL}}.\\]\nWith \\(V_{\\mathrm{BE,sat}} \\approx 0.65\\text{–}0.85\\,\\mathrm{V}\\) and \\(V_{\\mathrm{OL}} \\approx 0.2\\text{–}0.4\\,\\mathrm{V}\\), \\[V_{\\mathrm{RB}} \\approx 3.3 - (0.65\\text{–}0.85) - (0.2\\text{–}0.4) \\approx 2.45\\text{–}2.05\\,\\mathrm{V}.\\]\nFor \\(R_{\\mathrm{B}} = 1\\,\\mathrm{k\\Omega}\\), \\[I_{\\mathrm{B}} \\approx \\frac{V_{\\mathrm{RB}}}{R_{\\mathrm{B}}} \\approx 2.05\\text{–}2.45\\,\\mathrm{mA}.\\]\nForced-beta check \\(\\beta_{\\mathrm{forced}} = I_{\\mathrm{C}} / I_{\\mathrm{B}}\\):\n\nTypical brightness (\\(I_{\\mathrm{seg}} \\approx 4.38\\,\\mathrm{mA}\\)):   \\(I_{\\mathrm{C}} \\approx 30.6\\,\\mathrm{mA}\\),   \\(\\beta_{\\mathrm{forced}} \\approx 12.5\\text{–}15\\).\nConservative brightness (\\(I_{\\mathrm{seg}} \\approx 2.71\\,\\mathrm{mA}\\)):   \\(I_{\\mathrm{C}} \\approx 19.0\\,\\mathrm{mA}\\),   \\(\\beta_{\\mathrm{forced}} \\approx 7.8\\text{–}9.3\\).\n\nThese values are suitable for saturating a 2N3906 in this current range."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#technical-documentation",
    "href": "labs/Lab 2/Lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nCode directory (this lab):\n\ntop.sv — top level (HSOSC @ 6 MHz, Dmux, SevenSeg, Sum LEDs)\nDmux.sv — divider + input select + digit enables\nSevenSeg.sv — hex→7‑segment decoder (active‑LOW)\n*_tb.sv — basic testbenches (SevenSeg_tb.sv, Dmux_tb.sv, top_tb.sv)\n\nTools: Radiant (synthesis, constraints, Netlist Analyzer), QuestaSim Lattice Edition (simulation).\n\n\nNotes that matter for this lab\n\nActive‑LOW segments. Common‑anode means driving a 0 turns a segment ON. Keep all case patterns consistent with this polarity.\nOne decoder only. Both digits share the same decoder → time‑multiplex inputs and enables.\nBrightness uniformity. Identical per‑segment resistors and a fixed 50% duty for each digit keep perceived brightness similar across numbers.\nScan rate. If you observe flicker or “ghosting,” increase \\(f_{\\text{scan}}\\) (reduce N)."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#results-discussion",
    "href": "labs/Lab 2/Lab2.html#results-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results & Discussion",
    "text": "Results & Discussion\n\nThe decoder produced the correct segment patterns for 0x0–0xF in simulation and on the physical board. The summing LED’s also followed the expected behavior.\n\nAt (N=60,000) (≈50 Hz scan), both digits are readable, with no visible flicker present.\nThe 5‑bit Sum LEDs matched Sw1 + Sw2 for all 256 input pairs in the top‑level test."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#conclusion",
    "href": "labs/Lab 2/Lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nI met the Lab 2 requirements: a single seven‑segment decoder time‑multiplexed across two digits, the sum on five LEDs, and current‑safe driving using PNP anode switches with per‑segment resistors. The design is modular (Dmux, SevenSeg, top) and synthesizes cleanly.\nTime spent: (8) hours."
  },
  {
    "objectID": "labs/Lab 2/Lab2.html#ai-implementation",
    "href": "labs/Lab 2/Lab2.html#ai-implementation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Implementation",
    "text": "AI Implementation\n\nPrompt used\n\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\n\n\nWhat the LLM produced\n\nGood ideas it used\n\nKept one hex→7-segment decoder and time-multiplexed the inputs (correct per spec).\nAdded a parameterized scan divider with $clog2 sizing and a clean always_ff counter.\nSplit the design into clear modules: a scan/mux block (selects nibble + digit enables) and the existing decoder.\nUsed always_comb for pure combinational logic and documented active-LOW segment polarity (common-anode).\nSuggested a sim mode with a tiny divider under ifndef SYNTHESIS to speed testbenches.\n\nGaps I had to fix\n\nThe first draft instantiated the decoder twice (one per digit). I rewired to feed a single decoder with the selected nibble.\nDigit enable polarity was backward for a PNP high-side scheme; I inverted the enables so only one anode is ON at a time.\n\n\n\n\nQuality rating (and why)\n\nRating: B+\nWhy: Architecture and modularity were solid, scan logic was close to correct, and it respected the “single decoder” objective after edits. Minor polarity mistakes and a comment/math mismatch kept it from an A.\n\n\n\nDid it synthesize first time?\n\nNot exactly. With the provided oscillator and decoder, it built after two small fixes:\n\nRemoved the duplicate decoder instance and fed the single instance from the scan mux.\n\nFlipped digit-enable polarity to match the common-anode via PNP wiring.\n\n\n\n\nWhat I’d do differently next time with an LLM\n\nPin down polarity & wiring in the prompt: “common-anode, active-LOW segments, PNP digit enables, single decoder” to avoid the duplicate-decoder and enable-polarity missteps.\n\nSpecify the exact primitives up front: “use the provided HSOSC and SegDisp modules by name” to prevent library/primitive swaps."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html",
    "href": "labs/Lab 1/Lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab I assembled the E155 development board, verified power rails, and brought up both the UPduino v3.1 FPGA (iCE40-UP5K) and the Nucleo-L432KC MCU. I then wrote SystemVerilog to (1) drive three LEDs per the given truth tables and (2) decode a 4-bit input from the on-board DIP switches (SW6) to a common-anode 7-segment display. The switches provide s[3:0] directly into the FPGA; the decoder drives seg[6:0] (active-low) through 1k ohm resistors to the display so that the selected hex digit lights correctly. Designs were simulated in QuestaSim, synthesized in Lattice Radiant, and programmed to the UP5K;"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#introduction",
    "href": "labs/Lab 1/Lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab I assembled the E155 development board, verified power rails, and brought up both the UPduino v3.1 FPGA (iCE40-UP5K) and the Nucleo-L432KC MCU. I then wrote SystemVerilog to (1) drive three LEDs per the given truth tables and (2) decode a 4-bit input from the on-board DIP switches (SW6) to a common-anode 7-segment display. The switches provide s[3:0] directly into the FPGA; the decoder drives seg[6:0] (active-low) through 1k ohm resistors to the display so that the selected hex digit lights correctly. Designs were simulated in QuestaSim, synthesized in Lattice Radiant, and programmed to the UP5K;"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#design-testing-methodology",
    "href": "labs/Lab 1/Lab1.html#design-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design & Testing Methodology",
    "text": "Design & Testing Methodology\n\nArchitecture\n\nInternal 48 MHz HSOSC feeds a power-on reset counter and a parameterized divider that creates a ~2.4 Hz tick for led[2].\nled_logic implements the required LED truth tables and optional active-low polarity.\nSevenSeg is a combinational hex→segments decoder with active-low outputs (for a common-anode display).\n\n\n\n\n\n\n\nFigure 1: Block diagram of the top-level (sbf_lab1).\n\n\n\n\n\nUnit tests (simulation)\nSelf-checking testbenches read .tv vectors: - tb_SevenSeg_tv verifies the 0x0–0xF map. - tb_led_logic_tv checks both active-high and active-low instances. - tb_lab1_sbf_tv checks seg and led[1:0] at top level (blink bit ignored).\n\nOn the single “error”: one vector intentionally contains unknowns (xxxxxxx) to represent a “don’t-care” state during initialization. The testbench expects xxxxxxx, while real hardware (with pull-ups and reset) resolves to 1111111 (all segments off). Functionally correct; the failure is in the expected vector, not the DUT.\n\n\n\nHardware bring-up\n\nVerified +5 V and +3.3 V LDO outputs on VIN power before inserting modules.\nWired one side of the dual 7-segment (common-anode) with series resistors on each segment; anode to 3.3 V.\nUsed ~1 kΩ series resistors → ≈3.3 mA/segment (ignoring LED (V_f)), comfortably within limits: [ I = 3.3  ]\n\n\n\n\n\n\n\nFigure 2: Hand-drawn schematic and current note (common-anode with ~1 kΩ resistors)."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#technical-documentation",
    "href": "labs/Lab 1/Lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation",
    "text": "Technical Documentation\n\nCode directory: https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201\n\nFPGA design: `sbf_lab1 (top).\nTestbenches: tb_all.sv.\n\nTools: Radiant (synthesis, constraints, Netlist Analyzer), QuestaSim Lattice Edition (simulation), SEGGER Embedded Studio (MCU).\n\n\nLED behavior specification\n\n\n\nS1\nS0\nled[0]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nON\n\n\n1\n0\nON\n\n\n1\n1\nOFF\n\n\n\n\n\n\nS3\nS2\nled[1]\n\n\n\n\n0\n0\nOFF\n\n\n0\n1\nOFF\n\n\n1\n0\nOFF\n\n\n1\n1\nON\n\n\n\nled[2] blinks at ~2.4 Hz from the divider: \\[\n\\mathrm{TOGGLE\\_COUNT}\n= \\frac{48\\,\\mathrm{MHz}}{2 \\cdot 2.4\\,\\mathrm{Hz}} - 1\n= 10{,}000{,}000 - 1\n\\]\n\n\nSeven-segment notes\n\nCommon-anode display → active-low segment lines (0 turns a segment on).\nNaming: seg[0]=A … seg[6]=G.\nTo turn on correct segments:"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#results-discussion",
    "href": "labs/Lab 1/Lab1.html#results-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results & Discussion",
    "text": "Results & Discussion\n\nSeven-segment unit tests\n\n\n\n\n\n\n\n\nFigure 3: SevenSeg waves across 0x0–0xF.\n\n\n\n\n\n\n\n\n\n\nFigure 4: SevenSeg transcript (1 expected X-case mismatch at vec 0).\n\n\n\n\n\n\n\nLED logic unit tests\n\n\n\n\n\n\n\n\nFigure 5: LED logic waves (active-high and active-low instances).\n\n\n\n\n\n\n\n\n\n\nFigure 6: LED logic transcript (all pass).\n\n\n\n\n\n\n\nTop-level simulation\n\n\n\n\n\n\n\n\nFigure 7: Top-level (sbf_lab1) QuestaSim waves sweeping s=0..F.\n\n\n\n\n\n\n\n\n\n\nFigure 8: Top-level transcript (1 error corresponds to X-expectation init vector).\n\n\n\n\n\nInterpretation.\n- led_logic passes all vectors for both polarities.\n- SevenSeg and top-level each show one flagged vector where the testbench expects unknowns; hardware resolves to all off (1111111). Functionality is correct; the discrepancy is only in the expected file’s init case.\n- Divider math and POR behavior match intent; led[2] toggles at the expected rate (simulation time scaled)."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#conclusion",
    "href": "labs/Lab 1/Lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nI assembled and powered the E155 dev board, verified MCU↔︎FPGA connectivity, and implemented the required FPGA logic: LED truth tables, a ~2.4 Hz blink, and a combinational 7-segment decoder for a common-anode display. Simulation, synthesis, and on-board testing confirm correct behavior. The lone “failure” in automated tests is a deliberate X-expectation vector that resolves to “all off” in hardware.\nTime spent: 20 hours."
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#all-code-httpsgithub.coms4anti4goe155treemainfpgaradiantprojectlab201",
    "href": "labs/Lab 1/Lab1.html#all-code-httpsgithub.coms4anti4goe155treemainfpgaradiantprojectlab201",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "All Code https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201",
    "text": "All Code https://github.com/s4anti4go/E155/tree/main/FPGA/RadiantProject/Lab%201"
  },
  {
    "objectID": "labs/Lab 1/Lab1.html#ai-implementation",
    "href": "labs/Lab 1/Lab1.html#ai-implementation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Implementation",
    "text": "AI Implementation\n\nPrompt\n\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nWhat the LLM produced (Gemini)\nGood ideas it used: - Parameterized divider (CLK_FREQ, BLINK_FREQ) with $clog2 sizing - Modern SV constructs (logic, always_ff) - Clear split: top module that wraps an oscillator primitive + a blinker child\nTop-level snippet returned (abridged): module led_blink_top (output logic o_led); logic clk_48mhz; SB_HFOSC u_hfosc ( .CLKHFPU(1’b1), .CLKHFEN(1’b1), .CLKHF(clk_48mhz) ); defparam u_hfosc.CLKHF_DIV = “0b00”; // 48 MHz led_blinker u_led_blinker (.clk(clk_48mhz), .led(o_led)); endmodule\n\n\nSynthesis outcome\nRadiant failed at the oscillator instantiation with: VERI-1063: instantiating unknown module SB_HFOSC Root cause: Radiant’s iCE40 UltraPlus technology library expects the HSOSC primitive, not SB_HFOSC (the SB_* form is common in iCEcube2 examples).\nFix applied (works in Radiant): // iCE40UP internal HF oscillator HSOSC #(.CLKHF_DIV(2’b00)) // 00 = 48 MHz hf_osc (.CLKHFPU(1’b1), .CLKHFEN(1’b1), .CLKHF(clk));\nI also replaced the LLM’s initial-based register inits with a tiny synchronous power-on reset (POR) counter so hardware powers up in a known state.\n\n\nQuality rating (and why)\n\nRating: B\n\nStrengths: idiomatic SV, readable, correct divide-by-N math, parameterized for reuse\n\nWeak spots: vendor primitive mismatch (SB_HFOSC vs HSOSC), defparam string style (\"0b00\"), reliance on initial for synthesis reset\n\n\n\nWhat I learned / new constructs\n\n$clog2 is handy for auto-sizing counters and synthesizes cleanly on UP5K.\nParameterizing the blink frequency made switching between 2 Hz (prompt) and 2.4 Hz (lab) a one-line change.\n\n\n\nErrors & warnings encountered\n\nRadiant: VERI-1063 instantiating unknown module SB_HFOSC → resolved by switching to HSOSC #(.CLKHF_DIV(2'b00)) and wiring CLKHFPU/CLKHFEN/CLKHF.\n\n\n\nTips for using LLMs for HDL (next-time playbook)\n\nSpecify tool, family, and exact primitive in the prompt: target Lattice Radiant for iCE40 UltraPlus (UP5K) and instantiate HSOSC (ports CLKHFPU, CLKHFEN, CLKHF; param CLKHF_DIV).\nAsk for a synthesizable reset: avoid initial; include a synchronous reset or a small POR counter.\nRequest a sim-friendly testbench: faster divider + self-check to validate logic quickly.\nAsk for Radiant-specific guidance: prefer Device Constraint Editor notes over generic .lpf.\nIterate with exact error text: paste Radiant/Questa messages back to the LLM for precise fixes.\n\n\n\nAppendix: Figure index\n\nBlock diagram: hmc-e155-portfolio/labs/Lab1/images/sv.jpg\n\nSchematic & current calc: hmc-e155-portfolio/labs/Lab1/images/elec.jpg\n\nTop-level waves: hmc-e155-portfolio/labs/Lab1/images/lab test waves.png, hmc-e155-portfolio/labs/Lab1/images/lab vectors.png\n\nLED unit waves: hmc-e155-portfolio/labs/Lab1/images/led test waves.png, hmc-e155-portfolio/labs/Lab1/images/led text tests.png\n\nSeven-seg waves: hmc-e155-portfolio/labs/Lab1/images/seven seg waves.png, hmc-e155-portfolio/labs/Lab1/images/seven seg tests.png"
  },
  {
    "objectID": "posts/FirstPost.html",
    "href": "posts/FirstPost.html",
    "title": "First Post!",
    "section": "",
    "text": "I’m excited for MicroPs because I get to see my code affect hardware in the real world. Writing something, probing a pin, and watching the scope confirm it did what I intended is the kind of feedback loop that makes the work satisfying and helps me absorb information.\nThis semester I want to build fluency in the basics that make systems reliable: read reference manuals without getting stuck, set up clocks cleanly, bring up GPIO/timers/serial, and write small drivers with clear init and ISR paths. I want to use interrupts and DMA with intent, understand when HAL or an RTOS helps (and when it doesn’t), and get better at debugging with a logic analyzer and scope instead of guessing.\nBy the end, I’m excited to be able to partake in a focused project I care about that uses the information I learned from the class. Looking forward to it :D"
  },
  {
    "objectID": "resources/resource1.html",
    "href": "resources/resource1.html",
    "title": "E155 Course Page",
    "section": "",
    "text": "https://hmc-e155.github.io"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hi! I’m Santiago Burgos-Fallon, a senior Engineering student at Harvey Mudd College. I love everything computers, from digital design and embedded systems to data analysis. This summer I worked at TSMC in Lithography Process Engineering, where I analyzed overlay relationships, tuned control systems, and pushed on design-for-manufacturability to improve chip yield and performance. Ive built practical digital systems including a 16 bit IEEE-754 FMA and a drone navigation project that fuses computer vision with ultra-wideband (UWB) positioning. Ive also done work relating healthcare tooling and AI for making healthcare more accesible. Currently, I am co-authoring a paper using Python-heavy data processing and visualization techniques to correlate air quality and Segregation in West Oakland. I like projects where I can go end-to-end: define the problem, model the data, write the code, and deliver something impactful."
  },
  {
    "objectID": "Resources.html",
    "href": "Resources.html",
    "title": "Resources",
    "section": "",
    "text": "MAN 6400 Data Sheet\n\n\nhttps://hmc-e155.github.io/assets/doc/MAN64x0%20Series.pdf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE155 Course Page\n\n\nWhat the title says\n\n\n\n\n\n\n\n\nNo matching items"
  }
]